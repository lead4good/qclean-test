<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QuantConnect.Lean.Engine</name>
    </assembly>
    <members>
        <member name="T:QuantConnect.Lean.Engine.AlgorithmManager">
             <summary>
             Algorithm manager class executes the algorithm and generates and passes through the algorithm events.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.State">
             <summary>
             Publicly accessible algorithm status
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.AlgorithmId">
             <summary>
             Public access to the currently running algorithm id.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.CurrentTimeStepElapsed">
             <summary>
             Gets the amount of time spent on the current time step
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.AlgorithmManager.TimeLoopWithinLimits">
             <summary>
             Gets a function used with the Isolator for verifying we're not spending too much time in each
             algo manager timer loop
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.QuitState">
             <summary>
             Quit state flag for the running algorithm. When true the user has requested the backtest stops through a Quit() method.
             </summary>
             <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.Quit(System.String)" />
            </member>
        <member name="P:QuantConnect.Lean.Engine.AlgorithmManager.DataPoints">
             <summary>
             Gets the number of data points processed per second
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.#ctor(System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.AlgorithmManager" /> class
             </summary>
             <param name="liveMode">True if we're running in live mode, false for backtest mode</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.Run(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Interfaces.ICommandQueueHandler,System.Threading.CancellationToken)">
             <summary>
             Launch the algorithm manager to run this strategy
             </summary>
             <param name="job">Algorithm job</param>
             <param name="algorithm">Algorithm instance</param>
             <param name="feed">Datafeed object</param>
             <param name="transactions">Transaction manager object</param>
             <param name="results">Result handler object</param>
             <param name="realtime">Realtime processing object</param>
             <param name="commands">The command queue for relaying extenal commands to the algorithm</param>
             <param name="token">Cancellation token</param>
             <remarks>Modify with caution</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.SetStatus(QuantConnect.AlgorithmStatus)">
             <summary>
             Set the quit state.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.AddMethodInvoker``1(QuantConnect.Interfaces.IAlgorithm,System.Collections.Generic.Dictionary{System.Type,Fasterflect.MethodInvoker},System.String)">
             <summary>
             Adds a method invoker if the method exists to the method invokers dictionary
             </summary>
             <typeparam name="T">The data type to check for 'OnData(T data)</typeparam>
             <param name="algorithm">The algorithm instance</param>
             <param name="methodInvokers">The dictionary of method invokers</param>
             <param name="methodName">The name of the method to search for</param>
             <returns>True if the method existed and was added to the collection</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.HandleDelistedSymbols(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Data.Market.Delistings,System.Collections.Generic.ICollection{QuantConnect.Data.Market.Delisting})">
             <summary>
             Performs delisting logic for the securities specified in <paramref name="newDelistings" /> that are marked as <see cref="F:QuantConnect.DelistingType.Delisted" />. 
             This includes liquidating the position and removing the security from the algorithm's collection.
             If we're unable to liquidate the position (maybe daily data or EOD already) then we'll add it to the <paramref name="delistings" />
             for the algo manager time loop to check later
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.AlgorithmManager.SampleBenchmark(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,System.DateTime)">
             <summary>
             Samples the benchmark in a  try/catch block
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ApiDataFileProvider">
             <summary>
             Attempts to download data from the api and save it in the data folder specified in config.json.
             This implementation will overwrite data if it already exists.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1">
             <summary>
             Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1" />
             that aggregates an underlying <see cref="T:System.Collections.Generic.IEnumerator`1" /> into a single
             data packet
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator" /> class
             This will aggregate instances emitted from the underlying enumerator and tag them with the
             specified symbol
             </summary>
             <param name="enumerator">The underlying enumerator to aggregate</param>
             <param name="symbol">The symbol to place on the aggregated collection</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.CreateCollection(QuantConnect.Symbol,System.DateTime,System.DateTime)">
             <summary>
             Creates a new, empty <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection" />.
             </summary>
             <param name="symbol">The base data collection symbol</param>
             <param name="time">The start time of the collection</param>
             <param name="endTime">The end time of the collection</param>
             <returns>A new, empty <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection" /></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.Add(`0,QuantConnect.Data.BaseData)">
             <summary>
             Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData" /> to the current collection
             </summary>
             <param name="collection">The collection to be added to</param>
             <param name="current">The data to be added</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1.SetData(`0,System.Collections.Generic.List{QuantConnect.Data.BaseData})">
             <summary>
             Adds all specified instances of <see cref="T:QuantConnect.Data.BaseData" /> to the current collection
             </summary>
             <param name="collection">The collection to be added to</param>
             <param name="current">The data collection to be added</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator">
             <summary>
             Provides a non-generic implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator`1" />
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.BaseDataCollectionAggregatorEnumerator" /> class
             </summary>
             <param name="enumerator">The enumerator to aggregate</param>
             <param name="symbol">The output data's symbol</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1">
             <summary>
             An implementation of <see cref="T:System.Collections.Generic.IEnumerator`1" /> that relies on the
             <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator{`0}.Enqueue(`0)" /> method being called and only ends when <see cref="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator{`0}.Stop" />
             is called
             </summary>
             <typeparam name="T">The item type yielded by the enumerator</typeparam>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Count">
             <summary>
             Gets the current number of items held in the internal queue
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.LastEnqueued">
             <summary>
             Gets the last item that was enqueued
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.#ctor(System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1" /> class
             </summary>
             <param name="blocking">Specifies whether or not to use the blocking behavior</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Enqueue(`0)">
             <summary>
             Enqueues the new data into this enumerator
             </summary>
             <param name="data">The data to be enqueued</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Stop">
             <summary>
             Signals the enumerator to stop enumerating when the items currently
             held inside are gone. No more items will be added to this enumerator.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.EnqueueableEnumerator`1.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory" /> that reads
             an entire <see cref="T:QuantConnect.Data.SubscriptionDataSource" /> into a single <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection" />
             to be emitted on the tradable date at midnight
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory" /> class.
             </summary>
             <param name="tradableDaysProvider">Function used to provide the tradable dates to be enumerator.
             Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays" /></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataCollectionSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Creates an enumerator to read the specified request
             </summary>
             <param name="request">The subscription request to be read</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <returns>An enumerator reading the subscription request</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory">
             <summary>
             Provides a default implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory" /> that uses
             <see cref="T:QuantConnect.Data.BaseData" /> factory methods for reading sources
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.#ctor(QuantConnect.Data.Auxiliary.MapFileResolver,QuantConnect.Interfaces.IFactorFileProvider,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="tradableDaysProvider">Function used to provide the tradable dates to be enumerator.
             Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays" /></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="tradableDaysProvider">Function used to provide the tradable dates to be enumerator.
             Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays" /></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.BaseDataSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Creates an enumerator to read the specified request
             </summary>
             <param name="request">The subscription request to be read</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <returns>An enumerator reading the subscription request</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator">
             <summary>
             Enumerates live futures symbol universe data into <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection" /> instances
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.#ctor(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.List{QuantConnect.Data.BaseData})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator" /> class.
             </summary>
             <param name="symbol">Futures contract symbol</param>
             <param name="underlying">Underlying enumerator</param>
             <param name="symbolUniverse">Symbol universe of the data queue</param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Current">
             <summary>
             Returns current futures chain enumerator position 
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Returns current futures chain enumerator position 
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueFuturesChainUniverseDataCollectionEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator">
             <summary>
             Enumerates live options symbol universe data  into <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection" /> instances
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.#ctor(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.List{QuantConnect.Data.BaseData})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator" /> class.
             </summary>
             <param name="symbol">Option contract symbol</param>
             <param name="underlying">Underlying enumerator</param>
             <param name="symbolUniverse">Symbol universe of the data queue</param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Current">
             <summary>
             Returns current option chain enumerator position 
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Returns current option chain enumerator position 
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.DataQueueOptionChainUniverseDataCollectionEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory" /> that reads
             an entire <see cref="T:QuantConnect.Data.SubscriptionDataSource" /> into a single <see cref="T:QuantConnect.Data.Fundamental.FineFundamental" />
             to be emitted on the tradable date at midnight
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory.#ctor(System.Boolean,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory" /> class.
             </summary>
             <param name="isLiveMode">True for live mode, false otherwise</param>
             <param name="tradableDaysProvider">Function used to provide the tradable dates to the enumerator.
             Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays" /></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Creates an enumerator to read the specified request
             </summary>
             <param name="request">The subscription request to be read</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <returns>An enumerator reading the subscription request</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FineFundamentalSubscriptionEnumeratorFactory.GetSource(QuantConnect.Data.Fundamental.FineFundamental,QuantConnect.Data.SubscriptionDataConfig,System.DateTime)">
             <summary>
             Returns a SubscriptionDataSource for the FineFundamental class, 
             returning data from a previous date if not available for the requested date
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory" /> for the <see cref="T:QuantConnect.Data.UniverseSelection.FuturesChainUniverse" /> in backtesting
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="enumeratorConfigurator">Function used to configure the sub-enumerators before sync (fill-forward/filter/ect...)</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory.#ctor(QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.Lean.Engine.DataFeeds.ITimeProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="symbolUniverse">Symbol universe provider of the data queue</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.FuturesChainUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Creates an enumerator to read the specified request
             </summary>
             <param name="request">The subscription request to be read</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <returns>An enumerator reading the subscription request</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory" /> for the <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverse" />
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}},QuantConnect.Data.Auxiliary.MapFileResolver,QuantConnect.Interfaces.IFactorFileProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="enumeratorConfigurator">Function used to configure the sub-enumerators before sync (fill-forward/filter/ect...)</param>
             <param name="mapFileResolver">Map file resolver</param>
             <param name="factorFileProvider">Factor file provider</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.#ctor(System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}},QuantConnect.Interfaces.IDataQueueUniverseProvider,QuantConnect.Lean.Engine.DataFeeds.ITimeProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="symbolUniverse">Symbol universe provider of the data queue</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.OptionChainUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Creates an enumerator to read the specified request
             </summary>
             <param name="request">The subscription request to be read</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <returns>An enumerator reading the subscription request</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory" /> that used the
             <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader" />
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.#ctor(QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataFileProvider,System.Boolean,System.Boolean,System.Func{QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Collections.Generic.IEnumerable{System.DateTime}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="resultHandler">The result handler for the algorithm</param>
             <param name="mapFileProvider">The map file provider</param>
             <param name="factorFileProvider">The factor file provider</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <param name="isLiveMode">True if runnig live algorithm, false otherwise</param>
             <param name="includeAuxiliaryData">True to check for auxiliary data, false otherwise</param>
             <param name="tradableDaysProvider">Function used to provide the tradable dates to be enumerator.
             Specify null to default to <see cref="P:QuantConnect.Data.UniverseSelection.SubscriptionRequest.TradableDays" /></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Creates a <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader" /> to read the specified request
             </summary>
             <param name="request">The subscription request to be read</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <returns>An enumerator reading the subscription request</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.SubscriptionDataReaderSubscriptionEnumeratorFactory.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.UserDefinedUniverseSubscriptionEnumeratorFactory">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Data.ISubscriptionEnumeratorFactory" /> to emit
             ticks based on <see cref="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.GetTriggerTimes(System.DateTime,System.DateTime,QuantConnect.Securities.MarketHoursDatabase)" />, allowing universe
             selection to fire at planned times.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.UserDefinedUniverseSubscriptionEnumeratorFactory.#ctor(QuantConnect.Data.UniverseSelection.UserDefinedUniverse,QuantConnect.Securities.MarketHoursDatabase)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.UserDefinedUniverseSubscriptionEnumeratorFactory" /> class
             </summary>
             <param name="universe">The user defined universe</param>
             <param name="marketHoursDatabase">The market hours database</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.Factories.UserDefinedUniverseSubscriptionEnumeratorFactory.CreateEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Creates an enumerator to read the specified request
             </summary>
             <param name="request">The subscription request to be read</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <returns>An enumerator reading the subscription request</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator">
             <summary>
             Provides the ability to fast forward an enumerator based on the age of the data
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Lean.Engine.DataFeeds.ITimeProvider,NodaTime.DateTimeZone,System.TimeSpan)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator" /> class
             </summary>
             <param name="enumerator">The source enumerator</param>
             <param name="timeProvider">A time provider used to determine age of data</param>
             <param name="timeZone">The data's time zone</param>
             <param name="maximumDataAge">The maximum age of data allowed</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FastForwardEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator">
             <summary>
             The FillForwardEnumerator wraps an existing base data enumerator and inserts extra 'base data' instances
             on a specified fill forward resolution
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Exchange">
             <summary>
             The exchange used to determine when to insert fill forward data
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.SecurityExchange,QuantConnect.Util.IReadOnlyRef{System.TimeSpan},System.Boolean,System.DateTime,System.TimeSpan)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator" /> class that accepts
             a reference to the fill forward resolution, useful if the fill forward resolution is dynamic
             and changing as the enumeration progresses
             </summary>
             <param name="enumerator">The source enumerator to be filled forward</param>
             <param name="exchange">The exchange used to determine when to insert fill forward data</param>
             <param name="fillForwardResolution">The resolution we'd like to receive data on</param>
             <param name="isExtendedMarketHours">True to use the exchange's extended market hours, false to use the regular market hours</param>
             <param name="subscriptionEndTime">The end time of the subscrition, once passing this date the enumerator will stop</param>
             <param name="dataResolution">The source enumerator's data resolution</param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.RequiresFillForwardData(System.TimeSpan,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData@)">
             <summary>
             Determines whether or not fill forward is required, and if true, will produce the new fill forward data
             </summary>
             <param name="fillForwardResolution"></param>
             <param name="previous">The last piece of data emitted by this enumerator</param>
             <param name="next">The next piece of data on the source enumerator</param>
             <param name="fillForward">When this function returns true, this will have a non-null value, null when the function returns false</param>
             <returns>True when a new fill forward piece of data was produced and should be emitted by this enumerator</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator.GetNextOpenDateAfter(System.DateTime)">
             <summary>
             Finds the next open date that follows the specified date, this functions expects a date, not a date time
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator">
             <summary>
             Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1" /> that will not emit
             data ahead of the frontier as specified by an instance of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider" />.
             An instance of <see cref="T:QuantConnect.TimeZoneOffsetProvider" /> is used to convert between UTC
             and the data's native time zone
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Lean.Engine.DataFeeds.ITimeProvider,QuantConnect.TimeZoneOffsetProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator" /> class
             </summary>
             <param name="enumerator">The underlying enumerator to make frontier aware</param>
             <param name="timeProvider">The time provider used for resolving the current frontier time</param>
             <param name="offsetProvider">An offset provider used for converting the frontier UTC time into the data's native time zone</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FrontierAwareEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator">
             <summary>
             An implementation of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FillForwardEnumerator" /> that uses an <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider" />
             to determine if a fill forward bar needs to be emitted
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator.#ctor(QuantConnect.Lean.Engine.DataFeeds.ITimeProvider,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.SecurityExchange,QuantConnect.Util.IReadOnlyRef{System.TimeSpan},System.Boolean,System.DateTime,System.TimeSpan)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator" /> class that accepts
             a reference to the fill forward resolution, useful if the fill forward resolution is dynamic
             and changing as the enumeration progresses
             </summary>
             <param name="timeProvider">The source of time used to gauage when this enumerator should emit extra bars when
             null data is returned from the source enumerator</param>
             <param name="enumerator">The source enumerator to be filled forward</param>
             <param name="exchange">The exchange used to determine when to insert fill forward data</param>
             <param name="fillForwardResolution">The resolution we'd like to receive data on</param>
             <param name="isExtendedMarketHours">True to use the exchange's extended market hours, false to use the regular market hours</param>
             <param name="subscriptionEndTime">The end time of the subscrition, once passing this date the enumerator will stop</param>
             <param name="dataResolution">The source enumerator's data resolution</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.LiveFillForwardEnumerator.RequiresFillForwardData(System.TimeSpan,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData,QuantConnect.Data.BaseData@)">
             <summary>
             Determines whether or not fill forward is required, and if true, will produce the new fill forward data
             </summary>
             <param name="fillForwardResolution"></param>
             <param name="previous">The last piece of data emitted by this enumerator</param>
             <param name="next">The next piece of data on the source enumerator, this may be null</param>
             <param name="fillForward">When this function returns true, this will have a non-null value, null when the function returns false</param>
             <returns>True when a new fill forward piece of data was produced and should be emitted by this enumerator</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator">
             <summary>
             Aggregates an enumerator into <see cref="T:QuantConnect.Data.UniverseSelection.FuturesChainUniverseDataCollection" /> instances
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator" /> class
             </summary>
             <param name="enumerator">The enumerator to aggregate</param>
             <param name="symbol">The output data's symbol</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.FuturesChainUniverseDataCollectionAggregatorEnumerator.Add(QuantConnect.Data.UniverseSelection.FuturesChainUniverseDataCollection,QuantConnect.Data.BaseData)">
             <summary>
             Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData" /> to the current collection
             </summary>
             <param name="collection">The collection to be added to</param>
             <param name="current">The data to be added</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator">
             <summary>
             Enumerates data into <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection" /> instances
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionAggregatorEnumerator" /> class
             </summary>
             <param name="enumerator">The enumerator to aggregate</param>
             <param name="symbol">The output data's symbol</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionEnumerator.Add(QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection,QuantConnect.Data.BaseData)">
             <summary>
             Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData" /> to the current collection
             </summary>
             <param name="collection">The collection to be added to</param>
             <param name="current">The data to be added</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionAggregatorEnumerator">
             <summary>
             Aggregates an enumerator into <see cref="T:QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection" /> instances
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionAggregatorEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Symbol)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionAggregatorEnumerator" /> class
             </summary>
             <param name="enumerator">The enumerator to aggregate</param>
             <param name="symbol">The output data's symbol</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OptionChainUniverseDataCollectionAggregatorEnumerator.Add(QuantConnect.Data.UniverseSelection.OptionChainUniverseDataCollection,QuantConnect.Data.BaseData)">
             <summary>
             Adds the specified instance of <see cref="T:QuantConnect.Data.BaseData" /> to the current collection
             </summary>
             <param name="collection">The collection to be added to</param>
             <param name="current">The data to be added</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator">
             <summary>
             Aggregates open interest bars ready to be time synced
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator.#ctor(System.TimeSpan,NodaTime.DateTimeZone,QuantConnect.Lean.Engine.DataFeeds.ITimeProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator" /> class
             </summary>
             <param name="barSize">The OI bar size to produce</param>
             <param name="timeZone">The time zone the raw data is time stamped in</param>
             <param name="timeProvider">The time provider instance used to determine when bars are completed and
             can be emitted</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator.ProcessData(QuantConnect.Data.Market.Tick)">
             <summary>
             Pushes the tick into this enumerator. This tick will be aggregated into a OI bar
             and emitted after the alotted time has passed
             </summary>
             <param name="data">The new data to be aggregated</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.OpenInterestEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator">
             <summary>
             Provides augmentation of how often an enumerator can be called. Time is measured using
             an <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider" /> instance and calls to the underlying enumerator are limited
             to a minimum time between each call.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Lean.Engine.DataFeeds.ITimeProvider,System.TimeSpan)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator" /> class
             </summary>
             <param name="enumerator">The underlying enumerator to place rate limits on</param>
             <param name="timeProvider">Time provider used for determing the time between calls</param>
             <param name="minimumTimeBetweenCalls">The minimum time allowed between calls to the underlying enumerator</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RateLimitEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1">
             <summary>
             Provides an implementation of <see cref="T:System.Collections.Generic.IEnumerator`1" /> that will
             always return true via MoveNext.
             </summary>
             <typeparam name="T"></typeparam>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1" /> class
             </summary>
             <param name="enumeratorFactory">Enumerator factory used to regenerate the underlying
             enumerator when it ends</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.RefreshEnumerator`1.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator">
             <summary>
             Implements a wrapper around a base data enumerator to provide a final filtering step
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError">
             <summary>
             Fired when there's an error executing a user's data filter
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.WrapForDataFeed(QuantConnect.Lean.Engine.Results.IResultHandler,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.Security,System.DateTime)">
             <summary>
             Convenience method to wrap the enumerator and attach the data filter event to log and alery users of errors
             </summary>
             <param name="resultHandler">Result handler reference used to send errors</param>
             <param name="enumerator">The source enumerator to be wrapped</param>
             <param name="security">The security who's data is being enumerated</param>
             <param name="endTime">The end time of the subscription</param>
             <returns>A new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator" /> class that has had it's <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError" />
             event subscribed to to send errors to the result handler</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.Securities.Security,System.DateTime)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator" /> class
             </summary>
             <param name="enumerator">The source enumerator to be wrapped</param>
             <param name="security">The security containing an exchange and data filter</param>
             <param name="endTime">The end time of the subscription</param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.OnDataFilterError(System.Exception)">
             <summary>
             Event invocated for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SubscriptionFilterEnumerator.DataFilterError" /> event
             </summary>
             <param name="exception">The exception that was thrown when trying to perform data filtering</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator">
             <summary>
             Represents an enumerator capable of synchronizing other base data enumerators in time.
             This assumes that all enumerators have data time stamped in the same time zone
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.#ctor(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator" /> class
             </summary>
             <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator" /> class
             </summary>
             <param name="enumerators">The enumerators to be synchronized. NOTE: Assumes the same time zone for all data</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.GetSynchronizedEnumerator(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
             <summary>
             Synchronization system for the enumerator:
             </summary>
             <param name="enumerators"></param>
             <returns></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.GetBinarySearchMethod(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
             <summary>
             Binary search for the enumerator stack synchronization
             </summary>
             <param name="enumerators"></param>
             <returns></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.ListInsert(QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.SynchronizedEnumerator[],System.Int32,QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.SynchronizedEnumerator,System.Int32)">
             <summary>
             Shuffle the enumerator position in the list.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.SynchronizingEnumerator.GetBruteForceMethod(System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData}[])">
             <summary>
             Brute force implementation for synchronizing the enumerator
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator">
             <summary>
             Aggregates ticks into quote bars ready to be time synced
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator.#ctor(System.TimeSpan,NodaTime.DateTimeZone,QuantConnect.Lean.Engine.DataFeeds.ITimeProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator" /> class
             </summary>
             <param name="barSize">The quote bar size to produce</param>
             <param name="timeZone">The time zone the raw data is time stamped in</param>
             <param name="timeProvider">The time provider instance used to determine when bars are completed and
             can be emitted</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator.ProcessData(QuantConnect.Data.BaseData)">
             <summary>
             Pushes the tick into this enumerator. This tick will be aggregated into a quote bar
             and emitted after the alotted time has passed
             </summary>
             <param name="data">The new data to be aggregated</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.QuoteBarBuilderEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator">
             <summary>
             Aggregates ticks into trade bars ready to be time synced
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator.#ctor(System.TimeSpan,NodaTime.DateTimeZone,QuantConnect.Lean.Engine.DataFeeds.ITimeProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator" /> class
             </summary>
             <param name="barSize">The trade bar size to produce</param>
             <param name="timeZone">The time zone the raw data is time stamped in</param>
             <param name="timeProvider">The time provider instance used to determine when bars are completed and
             can be emitted</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator.ProcessData(QuantConnect.Data.BaseData)">
             <summary>
             Pushes the tick into this enumerator. This tick will be aggregated into a bar
             and emitted after the alotted time has passed
             </summary>
             <param name="data">The new data to be aggregated</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Enumerators.TradeBarBuilderEnumerator.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DefaultDataFileProvider">
             <summary>
             Default file provider functionality that does not attempt to retrieve any data
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DefaultDataFileProvider.Fetch(QuantConnect.Symbol,System.DateTime,QuantConnect.Resolution,QuantConnect.TickType)">
             <summary>
             Does not attempt to retrieve any data
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader">
             <summary>
             Represents a type responsible for accepting an input <see cref="T:QuantConnect.Data.SubscriptionDataSource" />
             and returning an enumerable of the source's <see cref="T:QuantConnect.Data.BaseData" />
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.InvalidSource">
             <summary>
             Event fired when the specified source is considered invalid, this may
             be from a missing file or failure to download a remote source
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Reads the specified <paramref name="source" />
             </summary>
             <param name="source">The source to be read</param>
             <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the data in the source</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider">
             <summary>
             Provides access to the current time in UTC. This doesn't necessarily
             need to be wall-clock time, but rather the current time in some system
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider.GetUtcNow">
             <summary>
             Gets the current time in UTC
             </summary>
             <returns>The current time in UTC</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader">
             <summary>
             Collection Subscription Factory takes a BaseDataCollection from BaseData factories
             and yields it one point at a time to the algorithm
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.#ctor(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader" /> class
             </summary>
             <param name="config">The subscription's configuration</param>
             <param name="date">The date this factory was produced to read data for</param>
             <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.InvalidSource">
             <summary>
             Event fired when the specified source is considered invalid, this may
             be from a missing file or failure to download a remote source
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.ReaderError">
             <summary>
             Event fired when an exception is thrown during a call to 
             <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)" />
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Reads the specified <paramref name="source" />
             </summary>
             <param name="source">The source to be read</param>
             <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the data in the source</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.OnReaderError(System.String,System.Exception)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.ReaderError" /> event
             </summary>
             <param name="line">The line that caused the exception</param>
             <param name="exception">The exception that was caught</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.CollectionSubscriptionDataSourceReader.InvalidSource" /> event
             </summary>
             <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource" /> that was invalid</param>
             <param name="exception">The exception if one was raised, otherwise null</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider" /> that can be
             manually advanced through time
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.#ctor(NodaTime.DateTimeZone)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider" />
             </summary>
             <param name="setCurrentTimeTimeZone">Specify to use this time zone when calling <see cref="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)" />,
             leave null for the deault of <see cref="F:QuantConnect.TimeZones.Utc" /></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.#ctor(System.DateTime,NodaTime.DateTimeZone)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider" /> class
             </summary>
             <param name="currentTime">The current time in the specified time zone, if the time zone is
             null then the time is interpreted as being in <see cref="F:QuantConnect.TimeZones.Utc" /></param>
             <param name="setCurrentTimeTimeZone">Specify to use this time zone when calling <see cref="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)" />,
             leave null for the deault of <see cref="F:QuantConnect.TimeZones.Utc" /></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.GetUtcNow">
             <summary>
             Gets the current time in UTC
             </summary>
             <returns>The current time in UTC</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTimeUtc(System.DateTime)">
             <summary>
             Sets the current time interpreting the specified time as a UTC time
             </summary>
             <param name="time">The current time in UTC</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.SetCurrentTime(System.DateTime)">
             <summary>
             Sets the current time interpeting the specified time as a local time
             using the time zone used at instatiation.
             </summary>
             <param name="time">The local time to set the current time time, will be
             converted into UTC</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.Advance(System.TimeSpan)">
             <summary>
             Advances the current time by the specified span
             </summary>
             <param name="span">The amount of time to advance the current time by</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ManualTimeProvider.AdvanceSeconds(System.Double)">
             <summary>
             Advances the current time by the specified number of seconds
             </summary>
             <param name="seconds">The number of seconds to advance the current time by</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Queues.ApiDataQueueHandler">
             <summary>
             Bind to a live data websocket connection
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.ApiDataQueueHandler.#ctor">
             <summary>
             Constructor that initializes Api Connection
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.ApiDataQueueHandler.GetNextTicks">
             <summary>
             Get next ticks if they have arrived from the server.
             </summary>
             <returns>Array of <see cref="T:QuantConnect.Data.BaseData" /></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.ApiDataQueueHandler.Subscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
             <summary>
             Adds the specified symbols to the subscription
             </summary>
             <param name="job">Job we're subscribing for:</param>
             <param name="symbols">The symbols to be added keyed by SecurityType</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.ApiDataQueueHandler.Unsubscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
             <summary>
             Removes the specified symbols to the subscription
             </summary>
             <param name="job">Job that's being processed processing.</param>
             <param name="symbols">The symbols to be removed keyed by SecurityType</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.RealTimeProvider">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider" /> that
             uses <see cref="P:System.DateTime.UtcNow" /> to provide the current time
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.RealTimeProvider.GetUtcNow">
             <summary>
             Gets the current time in UTC
             </summary>
             <returns>The current time in UTC</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket">
             <summary>
             Defines a container type to hold data produced by a data feed subscription
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Security">
             <summary>
             The security
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Configuration">
             <summary>
             The subscription configuration that produced this data
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Count">
             <summary>
             Gets the number of data points held within this packet
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Data">
             <summary>
             The data for the security
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.#ctor(QuantConnect.Securities.Security,QuantConnect.Data.SubscriptionDataConfig)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket" /> class
             </summary>
             <param name="security">The security whose data is held in this packet</param>
             <param name="configuration">The subscription configuration that produced this data</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.#ctor(QuantConnect.Securities.Security,QuantConnect.Data.SubscriptionDataConfig,System.Collections.Generic.List{QuantConnect.Data.BaseData})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket" /> class
             </summary>
             <param name="security">The security whose data is held in this packet</param>
             <param name="configuration">The subscription configuration that produced this data</param>
             <param name="data">The data to add to this packet. The list reference is reused
             internally and NOT copied.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket.Add(QuantConnect.Data.BaseData)">
             <summary>
             Adds the specified data to this packet
             </summary>
             <param name="data">The data to be added to this packet</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection">
             <summary>
             Provides a collection for holding subscriptions.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection" /> class
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.Contains(QuantConnect.Data.SubscriptionDataConfig)">
             <summary>
             Checks the collection for the specified subscription configuration
             </summary>
             <param name="configuration">The subscription configuration to check for</param>
             <returns>True if a subscription with the specified configuration is found in this collection, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.ContainsAny(QuantConnect.Symbol)">
             <summary>
             Checks the collection for any subscriptions with the specified symbol
             </summary>
             <param name="symbol">The symbol to check</param>
             <returns>True if any subscriptions are found with the specified symbol</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryAdd(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
             <summary>
             Attempts to add the specified subscription to the collection. If another subscription
             exists with the same configuration then it won't be added.
             </summary>
             <param name="subscription">The subscription to add</param>
             <returns>True if the subscription is successfully added, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryGetValue(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Lean.Engine.DataFeeds.Subscription@)">
             <summary>
             Attempts to retrieve the subscription with the specified configuration
             </summary>
             <param name="configuration">The subscription's configuration</param>
             <param name="subscription">The subscription matching the configuration, null if not found</param>
             <returns>True if the subscription is successfully retrieved, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryGetAll(QuantConnect.Symbol,System.Collections.Generic.ICollection{QuantConnect.Lean.Engine.DataFeeds.Subscription}@)">
             <summary>
             Attempts to retrieve the subscription with the specified configuration
             </summary>
             <param name="symbol">The symbol of the subscription's configuration</param>
             <param name="subscriptions">The subscriptions matching the symbol, null if not found</param>
             <returns>True if the subscriptions are successfully retrieved, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryRemove(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Lean.Engine.DataFeeds.Subscription@)">
             <summary>
             Attempts to remove the subscription with the specified configuraton from the collection.
             </summary>
             <param name="configuration">The configuration of the subscription to remove</param>
             <param name="subscription">The removed subscription, null if not found.</param>
             <returns>True if the subscription is successfully removed, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.TryRemoveAll(QuantConnect.Symbol,System.Collections.Generic.ICollection{QuantConnect.Lean.Engine.DataFeeds.Subscription}@)">
             <summary>
             Attempts to remove all subscriptons for the specified symbol
             </summary>
             <param name="symbol">The symbol of the subscriptions to remove</param>
             <param name="subscriptions">The removed subscriptions</param>
             <returns></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.GetEnumerator">
             <summary>
             Returns an enumerator that iterates through the collection.
             </summary>
             <returns>
             An enumerator that can be used to iterate through the collection.
             </returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionCollection.System#Collections#IEnumerable#GetEnumerator">
             <summary>
             Returns an enumerator that iterates through a collection.
             </summary>
             <returns>
             An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
             </returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader">
             <summary>
             Provides an implementations of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader" /> that uses the 
             <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)" />
             method to read lines of text from a <see cref="T:QuantConnect.Data.SubscriptionDataSource" />
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.InvalidSource">
             <summary>
             Event fired when the specified source is considered invalid, this may
             be from a missing file or failure to download a remote source
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError">
             <summary>
             Event fired when an exception is thrown during a call to 
             <see cref="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)" />
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.CreateStreamReaderError">
             <summary>
             Event fired when there's an error creating an <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader" /> or the
             instantiated <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader" /> has no data.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataFileProvider,QuantConnect.Lean.Engine.DataFeeds.DataFileCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader" /> class
             </summary>
             <param name="dataFileProvider">Attempts to fetch remote file provider</param>
             <param name="dataFileCacheProvider">This provider caches files if needed</param>
             <param name="config">The subscription's configuration</param>
             <param name="date">The date this factory was produced to read data for</param>
             <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataFileProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader" /> class
             </summary>
             <param name="dataFileProvider">Attempts to fetch remote file provider</param>
             <param name="config">The subscription's configuration</param>
             <param name="date">The date this factory was produced to read data for</param>
             <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Reads the specified <paramref name="source" />
             </summary>
             <param name="source">The source to be read</param>
             <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the data in the source</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.CreateStreamReader(QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader" /> for the specified <paramref name="subscriptionDataSource" />
             </summary>
             <param name="subscriptionDataSource">The source to produce an <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader" /> for</param>
             <returns>A new instance of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader" /> to read the source, or null if there was an error</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.InvalidSource" /> event
             </summary>
             <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource" /> that was invalid</param>
             <param name="exception">The exception if one was raised, otherwise null</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.OnReaderError(System.String,System.Exception)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError" /> event
             </summary>
             <param name="line">The line that caused the exception</param>
             <param name="exception">The exception that was caught</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.OnCreateStreamReaderError(System.DateTime,QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.CreateStreamReaderError" /> event
             </summary>
             <param name="date">The date of the source</param>
             <param name="source">The source that caused the error</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.HandleLocalFileSource(QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Opens up an IStreamReader for a local file source
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.HandleRemoteSourceFile(QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Opens up an IStreamReader for a remote file source
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs">
             <summary>
             Event arguments for the <see cref="M:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.CreateStreamReader(QuantConnect.Data.SubscriptionDataSource)" /> event
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.Date">
             <summary>
             Gets the date of the source
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.Source">
             <summary>
             Gets the source that caused the error
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs.#ctor(System.DateTime,QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.CreateStreamReaderErrorEventArgs" /> class
             </summary>
             <param name="date">The date of the source</param>
             <param name="source">The source that cause the error</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange">
             <summary>
             Provides a means of distributing output from enumerators from a dedicated separate thread
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SleepInterval">
             <summary>
             Gets or sets how long this thread will sleep when no data is available
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Name">
             <summary>
             Gets a name for this exchange
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.#ctor(System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange" />
             </summary>
             <param name="name">A name for this exchange</param>
             <param name="enumerators">The enumerators to fanout</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddEnumerator(QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler)">
             <summary>
             Adds the enumerator to this exchange. If it has already been added
             then it will remain registered in the exchange only once
             </summary>
             <param name="handler">The handler to use when this symbol's data is encountered</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddEnumerator(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Func{System.Boolean},System.Action{QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler})">
             <summary>
             Adds the enumerator to this exchange. If it has already been added
             then it will remain registered in the exchange only once
             </summary>
             <param name="symbol">A unique symbol used to identify this enumerator</param>
             <param name="enumerator">The enumerator to be added</param>
             <param name="shouldMoveNext">Function used to determine if move next should be called on this
             enumerator, defaults to always returning true</param>
             <param name="enumeratorFinished">Delegate called when the enumerator move next returns false</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SetErrorHandler(System.Func{System.Exception,System.Boolean})">
             <summary>
             Sets the specified function as the error handler. This function
             returns true if it is a fatal error and queue consumption should
             cease.
             </summary>
             <param name="isFatalError">The error handling function to use when an
             error is encountered during queue consumption. Returns true if queue
             consumption should be stopped, returns false if queue consumption should
             continue</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SetDataHandler(QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler)">
             <summary>
             Sets the specified hander function to handle data for the handler's symbol
             </summary>
             <param name="handler">The handler to use when this symbol's data is encountered</param>
             <returns>An identifier that can be used to remove this handler</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.SetDataHandler(QuantConnect.Symbol,System.Action{QuantConnect.Data.BaseData})">
             <summary>
             Sets the specified hander function to handle data for the handler's symbol
             </summary>
             <param name="symbol">The symbol whose data is to be handled</param>
             <param name="handler">The handler to use when this symbol's data is encountered</param>
             <returns>An identifier that can be used to remove this handler</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.AddDataHandler(QuantConnect.Symbol,System.Action{QuantConnect.Data.BaseData})">
             <summary>
             Adds the specified hander function to handle data for the handler's symbol 
             </summary>
             <param name="symbol">The symbol whose data is to be handled</param>
             <param name="handler">The handler to use when this symbol's data is encountered</param>
             <returns>An identifier that can be used to remove this handler</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.RemoveDataHandler(QuantConnect.Symbol)">
             <summary>
             Removes the handler with the specified identifier
             </summary>
             <param name="symbol">The symbol to remove handlers for</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.RemoveEnumerator(QuantConnect.Symbol)">
             <summary>
             Removes and returns enumerator handler with the specified symbol.
             The removed handler is returned, null if not found
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Start(System.Nullable{System.Threading.CancellationToken})">
             <summary>
             Begins consumption of the wrapped <see cref="T:QuantConnect.Interfaces.IDataQueueHandler" /> on
             a separate thread
             </summary>
             <param name="token">A cancellation token used to signal to stop</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Stop">
             <summary>
             Ends consumption of the wrapped <see cref="T:QuantConnect.Interfaces.IDataQueueHandler" />
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.ConsumeEnumerators(System.Threading.CancellationToken)">
             <summary> Entry point for queue consumption </summary>
             <param name="token">A cancellation token used to signal to stop</param>
             <remarks> This function only returns after <see cref="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.Stop" /> is called or the token is cancelled</remarks>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler">
             <summary>
             Handler used to handle data emitted from enumerators
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.DataEmitted">
             <summary>
             Event fired when MoveNext returns true and Current is non-null
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.Symbol">
             <summary>
             The symbol this handler handles
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.#ctor(QuantConnect.Symbol)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler" /> class
             </summary>
             <param name="symbol">The symbol whose data is to be handled</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.OnDataEmitted(QuantConnect.Data.BaseData)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.DataHandler.DataEmitted" /> event
             </summary>
             <param name="data">The data being emitted</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler">
             <summary>
             Handler used to manage a single enumerator's move next/end of stream behavior
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.EnumeratorFinished">
             <summary>
             Event fired when MoveNext returns false
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.Symbol">
             <summary>
             A unique symbol used to identify this enumerator
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.Enumerator">
             <summary>
             The enumerator this handler handles
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.HandlesData">
             <summary>
             Determines whether or not this handler is to be used for handling the
             data emitted. This is useful when enumerators are not for a single symbol,
             such is the case with universe subscriptions
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.#ctor(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Func{System.Boolean},System.Action{QuantConnect.Data.BaseData})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler" /> class
             </summary>
             <param name="symbol">The symbol to identify this enumerator</param>
             <param name="enumerator">The enumeator this handler handles</param>
             <param name="shouldMoveNext">Predicate function used to determine if we should call move next
             on the symbol's enumerator</param>
             <param name="handleData">Handler for data if HandlesData=true</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.#ctor(QuantConnect.Symbol,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler" /> class
             </summary>
             <param name="symbol">The symbol to identify this enumerator</param>
             <param name="enumerator">The enumeator this handler handles</param>
             <param name="handlesData">True if this handler will handle the data, false otherwise</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.OnEnumeratorFinished">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.EnumeratorFinished" /> event
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.ShouldMoveNext">
             <summary>
             Returns true if this enumerator should move next
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.BaseDataExchange.EnumeratorHandler.HandleData(QuantConnect.Data.BaseData)">
             <summary>
             Handles the specified data.
             </summary>
             <param name="data">The data to be handled</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed" /> that is designed to deal with
             live, remote data sources
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Subscriptions">
             <summary>
             Gets all of the current subscriptions this data feed is processing
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.IsActive">
             <summary>
             Public flag indicator that the thread is still busy.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Initializes the data feed for the specified job and algorithm
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.AddSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
             <summary>
             Adds a new subscription to provide data for the specified security.
             </summary>
             <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
             <returns>True if the subscription was created and added successfully, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.RemoveSubscription(QuantConnect.Data.SubscriptionDataConfig)">
             <summary>
             Removes the subscription from the data feed, if it exists
             </summary>
             <param name="configuration">The configuration of the subscription to remove</param>
             <returns>True if the subscription was successfully removed, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Run">
             <summary>
             Primary entry point.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.Exit">
             <summary>
             External controller calls to signal a terminate of the thread.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetDataQueueHandler">
             <summary>
             Gets the <see cref="T:QuantConnect.Interfaces.IDataQueueHandler" /> to use. By default this will try to load
             the type specified in the configuration via the 'data-queue-handler'
             </summary>
             <returns>The loaded <see cref="T:QuantConnect.Interfaces.IDataQueueHandler" /></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetTimeProvider">
             <summary>
             Gets the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider" /> to use. By default this will load the
             <see cref="T:QuantConnect.Lean.Engine.DataFeeds.RealTimeProvider" /> which use's the system's <see cref="P:System.DateTime.UtcNow" />
             for the current time
             </summary>
             <returns>he loaded <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ITimeProvider" /></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
             <summary>
             Creates a new subscription for the specified security
             </summary>
             <param name="request">The subscription request</param>
             <returns>A new subscription instance of the specified security</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.CreateUniverseSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
             <summary>
             Creates a new subscription for universe selection
             </summary>
             <param name="request">The subscription request</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetNextTicksEnumerator">
             <summary>
             Provides an <see cref="T:System.Collections.Generic.IEnumerator`1" /> that will continually dequeue data
             from the data queue handler while we're not cancelled
             </summary>
             <returns></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.UpdateFillForwardResolution">
             <summary>
             Updates the fill forward resolution by checking all existing subscriptions and
             selecting the smallest resoluton not equal to tick
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.GetEnumerator">
             <summary>
             Returns an enumerator that iterates through the collection.
             </summary>
             <returns>
             A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
             </returns>
             <filterpriority>1</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.System#Collections#IEnumerable#GetEnumerator">
             <summary>
             Returns an enumerator that iterates through a collection.
             </summary>
             <returns>
             An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler">
             <summary>
             Overrides methods of the base data exchange implementation
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler.ShouldMoveNext">
             <summary>
             Returns true if this enumerator should move next
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler.OnEnumeratorFinished">
             <summary>
             Calls stop on the internal enqueueable enumerator
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.LiveTradingDataFeed.EnumeratorHandler.HandleData(QuantConnect.Data.BaseData)">
             <summary>
             Enqueues the data
             </summary>
             <param name="data">The data to be handled</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter">
             <summary>
             Provides logic to prevent an algorithm from adding too many data subscriptions
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.#ctor(System.Func{System.Collections.Generic.IEnumerable{QuantConnect.Lean.Engine.DataFeeds.Subscription}},System.Int32,System.Int32,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter" /> class
             </summary>
             <param name="subscriptionsProvider">Delegate used to provide access to the current subscriptions</param>
             <param name="tickLimit">The maximum number of tick symbols</param>
             <param name="secondLimit">The maximum number of second symbols</param>
             <param name="minuteLimit">The maximum number of minute symbol</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.GetResolutionCount(QuantConnect.Resolution)">
             <summary>
             Get the number of securities that have this resolution.
             </summary>
             <param name="resolution">Search resolution value.</param>
             <returns>Count of the securities</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.GetRemaining(QuantConnect.Resolution)">
             <summary>
             Gets the number of available slots for the specifed resolution
             </summary>
             <param name="resolution">The resolution we want to add subscriptions at</param>
             <returns>The number of subscriptions we can safely add without maxing out the count (ram usage depends on other factors)</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.CanAddSubscription(QuantConnect.Resolution,System.String@)">
             <summary>
             Determines if we can add a subscription for the specified resolution
             </summary>
             <param name="resolution">The new subscription resolution to check</param>
             <param name="reason">When this function returns false, this is the reason we are unable to add the subscription</param>
             <returns>True if we can add a subscription for the specified resolution while
             remaining within our limits, false if this will put us over our limits</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.GetResolutionLimit(QuantConnect.Resolution)">
             <summary>
             Gets the max number of symbols for the specified resolution
             </summary>
             <param name="resolution">The resolution whose limit we seek</param>
             <returns>The specified resolution's limit</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.GetRamEstimate(System.Int32,System.Int32,System.Int32)">
             <summary>
             Estimated ram usage with this symbol combination:
             </summary>
             <returns>Decimal estimate of the number of MB ram the requested assets would consume</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.GetCountLimitReason(QuantConnect.Resolution)">
             <summary>
             Gets reason string for having a larger count than the limits
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionLimiter.GetMaxRamReason(System.Decimal)">
             <summary>
             Gets reason string for having a larger estimated ram usage than the limits
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer">
             <summary>
             Provides the ability to synchronize subscriptions into time slices
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SubscriptionFinished">
             <summary>
             Event fired when a subscription is finished
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.#ctor(QuantConnect.Lean.Engine.DataFeeds.UniverseSelection)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer" /> class
             </summary>
             <param name="universeSelection">The universe selection instance used to handle universe
             selection subscription output</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.Sync(System.DateTime,System.Collections.Generic.IEnumerable{QuantConnect.Lean.Engine.DataFeeds.Subscription},NodaTime.DateTimeZone,QuantConnect.Securities.CashBook,System.DateTime@)">
             <summary>
             Syncs the specifies subscriptions at the frontier time
             </summary>
             <param name="frontier">The time used for syncing, data in the future won't be included in this time slice</param>
             <param name="subscriptions">The subscriptions to sync</param>
             <param name="sliceTimeZone">The time zone of the created slice object</param>
             <param name="cashBook">The cash book, used for creating the cash book updates</param>
             <param name="nextFrontier">The next frontier time as determined by the first piece of data in the future ahead of the frontier.
             This value will equal DateTime.MaxValue when the subscriptions are all finished</param>
             <returns>A time slice for the specified frontier time</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.OnSubscriptionFinished(QuantConnect.Lean.Engine.DataFeeds.Subscription)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.SubscriptionSynchronizer.SubscriptionFinished" /> event
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Subscription">
             <summary>
             Represents the data required for a data feed to process a single subsciption
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Universe">
             <summary>
             Gets the universe for this subscription
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Subscription.Security">
             <summary>
             Gets the security this subscription points to
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Subscription.Configuration">
             <summary>
             Gets the configuration for this subscritions
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.TimeZone">
             <summary>
             Gets the data time zone associated with this subscription
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.Subscription.OffsetProvider">
             <summary>
             Gets the offset provider for time zone conversions to and from the data's local time
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.RealtimePrice">
             <summary>
             Gets the most current value from the subscription source
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.EndOfStream">
             <summary>
             Gets true if this subscription is finished, false otherwise
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.IsUniverseSelectionSubscription">
             <summary>
             Gets true if this subscription is used in universe selection
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.UtcStartTime">
             <summary>
             Gets the start time of this subscription in UTC
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.UtcEndTime">
             <summary>
             Gets the end time of this subscription in UTC
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.#ctor(QuantConnect.Data.UniverseSelection.Universe,QuantConnect.Securities.Security,QuantConnect.Data.SubscriptionDataConfig,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData},QuantConnect.TimeZoneOffsetProvider,System.DateTime,System.DateTime,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Subscription" /> class with a universe
             </summary>
             <param name="universe">Specified for universe subscriptions</param>
             <param name="security">The security this subscription is for</param>
             <param name="configuration">The subscription configuration that was used to generate the enumerator</param>
             <param name="enumerator">The subscription's data source</param>
             <param name="timeZoneOffsetProvider">The offset provider used to convert data local times to utc</param>
             <param name="utcStartTime">The start time of the subscription</param>
             <param name="utcEndTime">The end time of the subscription</param>
             <param name="isUniverseSelectionSubscription">True if this is a subscription for universe selection,
             that is, the configuration is used to produce the used to perform universe selection, false for a
             normal data subscription, i.e, SPY</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Reset">
             <summary>
             Sets the enumerator to its initial position, which is before the first element in the collection.
             </summary>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.Current">
             <summary>
             Gets the element in the collection at the current position of the enumerator.
             </summary>
             <returns>
             The element in the collection at the current position of the enumerator.
             </returns>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Subscription.System#Collections#IEnumerator#Current">
             <summary>
             Gets the current element in the collection.
             </summary>
             <returns>
             The current element in the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Subscription.GetHashCode">
             <summary>
             Serves as a hash function for a particular type. 
             </summary>
             <returns>
             A hash code for the current <see cref="T:System.Object" />.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs">
             <summary>
             Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader.InvalidSource" /> event
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.Source">
             <summary>
             Gets the source that was considered invalid
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.Exception">
             <summary>
             Gets the exception that was encountered
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs.#ctor(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.InvalidSourceEventArgs" /> class
             </summary>
             <param name="source">The source that was considered invalid</param>
             <param name="exception">The exception that was encountered</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader">
             <summary>
             Provides a factory method for creating <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader" /> instances
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader.ForSource(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Interfaces.IDataFileProvider,QuantConnect.Lean.Engine.DataFeeds.DataFileCacheProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
             <summary>
             Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader" /> capable of handling the specified <paramref name="source" />
             </summary>
             <param name="source">The subscription data source to create a factory for</param>
             <param name="dataFileProvider">Retrieves files if not found on disk</param>
             <param name="dataFileCacheProvider">Caches files</param>
             <param name="config">The configuration of the subscription</param>
             <param name="date">The date to be processed</param>
             <param name="isLiveMode">True for live mode, false otherwise</param>
             <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader" /> that can read the specified <paramref name="source" /></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataSourceReader.ForSource(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Interfaces.IDataFileProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
             <summary>
             Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader" /> capable of handling the specified <paramref name="source" />
             </summary>
             <param name="source">The subscription data source to create a factory for</param>
             <param name="dataFileProvider">Retrieves files if not found on disk</param>
             <param name="config">The configuration of the subscription</param>
             <param name="date">The date to be processed</param>
             <param name="isLiveMode">True for live mode, false otherwise</param>
             <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader" /> that can read the specified <paramref name="source" /></returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue">
             <summary>
             Live Data Queue is the cut out implementation of how to bind a custom live data source 
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.GetNextTicks">
             <summary>
             Desktop/Local doesn't support live data from this handler
             </summary>
             <returns>Tick</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Subscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
             <summary>
             Desktop/Local doesn't support live data from this handler
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.LiveDataQueue.Unsubscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
             <summary>
             Desktop/Local doesn't support live data from this handler
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue">
             <summary>
             This is an implementation of <see cref="T:QuantConnect.Interfaces.IDataQueueHandler" /> used for testing
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue" /> class to randomly emit data for each symbol
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.GetNextTicks">
             <summary>
             Get the next ticks from the live trading data queue
             </summary>
             <returns>IEnumerable list of ticks since the last update.</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Subscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
             <summary>
             Adds the specified symbols to the subscription
             </summary>
             <param name="job">Job we're subscribing for:</param>
             <param name="symbols">The symbols to be added keyed by SecurityType</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.Unsubscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
             <summary>
             Removes the specified symbols to the subscription
             </summary>
             <param name="job">Job we're processing.</param>
             <param name="symbols">The symbols to be removed keyed by SecurityType</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Queues.FakeDataQueue.PopulateQueue">
             <summary>
             Pumps a bunch of ticks into the queue
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs">
             <summary>
             Event arguments for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.TextSubscriptionDataSourceReader.ReaderError" /> event.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.Line">
             <summary>
             Gets the line that caused the error
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.Exception">
             <summary>
             Gets the exception that was caught
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs.#ctor(System.String,System.Exception)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ReaderErrorEventArgs" /> class
             </summary>
             <param name="line">The line that caused the error</param>
             <param name="exception">The exception that was caught during the read</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader">
             <summary>
             Subscription data reader is a wrapper on the stream reader class to download, unpack and iterate over a data file.
             </summary>
             <remarks>The class accepts any subscription configuration and automatically makes it availble to enumerate</remarks>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._config">
             Configuration of the data-reader:
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader._hasScaleFactors">
             true if we can find a scale factor file for the security of the form: ..\Lean\Data\equity\market\factor_files\{SYMBOL}.csv
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Current">
             <summary>
             Last read BaseData object from this type and source
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.System#Collections#IEnumerator#Current">
             <summary>
             Explicit Interface Implementation for Current
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.#ctor(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.DateTime,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Data.Auxiliary.MapFileResolver,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataFileProvider,System.Collections.Generic.IEnumerable{System.DateTime},System.Boolean,QuantConnect.Lean.Engine.DataFeeds.DataFileCacheProvider,System.Boolean)">
             <summary>
             Subscription data reader takes a subscription request, loads the type, accepts the data source and enumerate on the results.
             </summary>
             <param name="config">Subscription configuration object</param>
             <param name="periodStart">Start date for the data request/backtest</param>
             <param name="periodFinish">Finish date for the data request/backtest</param>
             <param name="resultHandler">Result handler used to push error messages and perform sampling on skipped days</param>
             <param name="mapFileResolver">Used for resolving the correct map files</param>
             <param name="factorFileProvider">Used for getting factor files</param>
             <param name="dataFileProvider">Used for getting files not present on disk</param>
             <param name="dataFileCacheProvider">Used for caching files</param>
             <param name="tradeableDates">Defines the dates for which we'll request data, in order, in the security's exchange time zone</param>
             <param name="isLiveMode">True if we're in live mode, false otherwise</param>
             <param name="includeAuxilliaryData">True if we want to emit aux data, false to only emit price data</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.MoveNext">
             <summary>
             Advances the enumerator to the next element of the collection.
             </summary>
             <returns>
             true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
             </returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.ResolveDataEnumerator(System.Boolean)">
             <summary>
             Resolves the next enumerator to be used in <see cref="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.MoveNext" />
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.TryGetNextDate(System.DateTime@)">
             <summary>
             Iterates the tradeable dates enumerator
             </summary>
             <param name="date">The next tradeable date</param>
             <returns>True if we got a new date from the enumerator, false if it's exhausted, or in live mode if we're already at today</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.UpdateScaleFactors(System.DateTime)">
             <summary>
             For backwards adjusted data the price is adjusted by a scale factor which is a combination of splits and dividends. 
             This backwards adjusted price is used by default and fed as the current price.
             </summary>
             <param name="date">Current date of the backtest.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Reset">
             <summary>
             Reset the IEnumeration
             </summary>
             <remarks>Not used</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.CheckForSplit(System.DateTime)">
             <summary>
             Check for dividends and emit them into the aux data queue
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.CheckForDividend(System.DateTime)">
             <summary>
             Check for dividends and emit them into the aux data queue
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.CheckForDelisting(System.DateTime)">
             <summary>
             Check for delistings and emit them into the aux data queue
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.GetRawClose">
             <summary>
             Un-normalizes the Previous.Value
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.SubscriptionDataReader.Dispose">
             <summary>
             Dispose of the Stream Reader and close out the source stream and file connections.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice">
             <summary>
             Represents a grouping of data emitted at a certain time.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.DataPointCount">
             <summary>
             Gets the count of data points in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice" />
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Time">
             <summary>
             Gets the time this data was emitted
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Data">
             <summary>
             Gets the data in the time slice
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Slice">
             <summary>
             Gets the <see cref="T:QuantConnect.Data.Slice" /> that will be used as input for the algorithm
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.CashBookUpdateData">
             <summary>
             Gets the data used to update the cash book
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.SecuritiesUpdateData">
             <summary>
             Gets the data used to update securities
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.ConsolidatorUpdateData">
             <summary>
             Gets the data used to update the consolidators
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.CustomData">
             <summary>
             Gets all the custom data in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice" />
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.SecurityChanges">
             <summary>
             Gets the changes to the data subscriptions as a result of universe selection
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.#ctor(System.DateTime,System.Int32,QuantConnect.Data.Slice,System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Securities.Cash}},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Securities.Security}},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Data.SubscriptionDataConfig}},System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.UpdateData{QuantConnect.Securities.Security}},QuantConnect.Data.UniverseSelection.SecurityChanges)">
             <summary>
             Initializes a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice" /> containing the specified data
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.Create(System.DateTime,NodaTime.DateTimeZone,QuantConnect.Securities.CashBook,System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.DataFeedPacket},QuantConnect.Data.UniverseSelection.SecurityChanges)">
             <summary>
             Creates a new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice" /> for the specified time using the specified data
             </summary>
             <param name="utcDateTime">The UTC frontier date time</param>
             <param name="algorithmTimeZone">The algorithm's time zone, required for computing algorithm and slice time</param>
             <param name="cashBook">The algorithm's cash book, required for generating cash update pairs</param>
             <param name="data">The data in this <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice" /></param>
             <param name="changes">The new changes that are seen in this time slice as a result of universe selection</param>
             <returns>A new <see cref="T:QuantConnect.Lean.Engine.DataFeeds.TimeSlice" /> containing the specified data</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.TimeSlice.PopulateDataDictionaries(QuantConnect.Data.BaseData,QuantConnect.Data.Market.Ticks,QuantConnect.Data.Market.TradeBars,QuantConnect.Data.Market.QuoteBars,QuantConnect.Data.Market.OptionChains,QuantConnect.Data.Market.FuturesChains)">
             <summary>
             Adds the specified <see cref="T:QuantConnect.Data.BaseData" /> instance to the appropriate <see cref="T:QuantConnect.Data.Market.DataDictionary`1" />
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader">
             <summary>
             Defines a transport mechanism for data from its source into various reader methods
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader.TransportMedium">
             <summary>
             Gets the transport medium of this stream reader
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader.EndOfStream">
             <summary>
             Gets whether or not there's more data to be read in the stream
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.IStreamReader.ReadLine">
             <summary>
             Gets the next line/batch of content from the stream 
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader">
             <summary>
             Represents a stream reader capable of reading lines from disk
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(System.String,System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader" /> class.
             </summary>
             <param name="source">The local file to be read</param>
             <param name="entryName">Specifies the zip entry to be opened. Leave null if not applicable,
             or to open the first zip entry found regardless of name</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(System.String,System.String,System.Int64)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader" /> class.
             </summary>
             <param name="source">The local file to be read</param>
             <param name="entryName">Specifies the zip entry to be opened. Leave null if not applicable,
             <param name="startingPosition">The starting position in the local file to be read</param>
             or to open the first zip entry found regardless of name</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.#ctor(Ionic.Zip.ZipFile,System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader" /> class.
             </summary>
             <param name="zipFile">The local zip archive to be read</param>
             <param name="entryName">Specifies the zip entry to be opened. Leave null if not applicable,
             or to open the first zip entry found regardless of name</param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.EntryFileNames">
             <summary>
             Returns the list of zip entries if local file stream reader is reading zip archive
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.TransportMedium">
             <summary>
             Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.LocalFile" />
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.EndOfStream">
             <summary>
             Gets whether or not there's more data to be read in the stream
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.ReadLine">
             <summary>
             Gets the next line/batch of content from the stream 
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.LocalFileSubscriptionStreamReader.Dispose">
             <summary>
             Disposes of the stream
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader">
             <summary>
             Represents a stream reader capabable of downloading a remote file and then
             reading it from disk
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.#ctor(System.String,System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader" /> class.
             </summary>
             <param name="source">The remote url to be downloaded via web client</param>
             <param name="downloadDirectory">The local directory and destination of the download</param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.TransportMedium">
             <summary>
             Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.RemoteFile" />
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.EndOfStream">
             <summary>
             Gets whether or not there's more data to be read in the stream
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.ReadLine">
             <summary>
             Gets the next line/batch of content from the stream 
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RemoteFileSubscriptionStreamReader.Dispose">
             <summary>
             Disposes of the stream
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader">
             <summary>
             Represents a stream reader capable of polling a rest client
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.#ctor(System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader" /> class.
             </summary>
             <param name="source">The source url to poll with a GET</param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.TransportMedium">
             <summary>
             Gets <see cref="F:QuantConnect.SubscriptionTransportMedium.Rest" />
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.EndOfStream">
             <summary>
             Gets whether or not there's more data to be read in the stream
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.ReadLine">
             <summary>
             Gets the next line/batch of content from the stream 
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.Transport.RestSubscriptionStreamReader.Dispose">
             <summary>
             This stream reader doesn't require disposal
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection">
             <summary>
             Provides methods for apply the results of universe selection to an algorithm
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.#ctor(QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.Controls)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection" /> class
             </summary>
             <param name="dataFeed">The data feed to add/remove subscriptions from</param>
             <param name="algorithm">The algorithm to add securities to</param>
             <param name="controls">Specifies limits on the algorithm's memory usage</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UniverseSelection.ApplyUniverseSelection(QuantConnect.Data.UniverseSelection.Universe,System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)">
             <summary>
             Applies universe selection the the data feed and algorithm
             </summary>
             <param name="universe">The universe to perform selection on</param>
             <param name="dateTimeUtc">The current date time in utc</param>
             <param name="universeData">The data provided to perform selection with</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1">
             <summary>
             Transport type for algorithm update data. This is intended to provide a
             list of base data used to perform updates against the specified target
             </summary>
             <typeparam name="T">The target type</typeparam>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Target">
             <summary>
             The target, such as a security or subscription data config
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.Data">
             <summary>
             The data used to update the target
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.DataType">
             <summary>
             The type of data in the data list
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1.#ctor(`0,System.Type,System.Collections.Generic.IReadOnlyList{QuantConnect.Data.BaseData})">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.UpdateData`1" /> class
             </summary>
             <param name="target">The end consumer/user of the dat</param>
             <param name="dataType">The type of data in the list</param>
             <param name="data">The update data</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.DataFileCacheProvider">
             <summary>
             File provider implements optimized zip archives caching facility. Cache is thread safe.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFileCacheProvider.Fetch(QuantConnect.Symbol,QuantConnect.Data.SubscriptionDataSource,System.DateTime,QuantConnect.Resolution,QuantConnect.TickType)">
             <summary>
             Does not attempt to retrieve any data
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.DataFileCacheProvider.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ISubscriptionDataSourceReader" /> that reads zip entry names
             </summary>
            </member>
        <member name="E:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.InvalidSource">
             <summary>
             Event fired when the specified source is considered invalid, this may
             be from a missing file or failure to download a remote source
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.#ctor(QuantConnect.Interfaces.IDataFileProvider,QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader" /> class
             </summary>
             <param name="dataFileProvider">Attempts to fetch remote file</param>
             <param name="config">The subscription's configuration</param>
             <param name="date">The date this factory was produced to read data for</param>
             <param name="isLiveMode">True if we're in live mode, false for backtesting</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.Read(QuantConnect.Data.SubscriptionDataSource)">
             <summary>
             Reads the specified <paramref name="source" />
             </summary>
             <param name="source">The source to be read</param>
             <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the data in the source</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.OnInvalidSource(QuantConnect.Data.SubscriptionDataSource,System.Exception)">
             <summary>
             Event invocator for the <see cref="E:QuantConnect.Lean.Engine.DataFeeds.ZipEntryNameSubscriptionDataSourceReader.InvalidSource" /> event
             </summary>
             <param name="source">The <see cref="T:QuantConnect.Data.SubscriptionDataSource" /> that was invalid</param>
             <param name="exception">The exception if one was raised, otherwise null</param>
            </member>
        <member name="T:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider">
             <summary>
             Provides an implementation of <see cref="T:QuantConnect.Interfaces.IHistoryProvider" /> that uses <see cref="T:QuantConnect.Data.BaseData" />
             instances to retrieve historical data
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.DataPointCount">
             <summary>
             Gets the total number of data points emitted by this history provider
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataFileProvider,System.Action{System.Int32})">
             <summary>
             Initializes this history provider to work for the specified job
             </summary>
             <param name="job">The job</param>
             <param name="mapFileProvider">Provider used to get a map file resolver to handle equity mapping</param>
             <param name="factorFileProvider">Provider used to get factor files to handle equity price scaling</param>
             <param name="dataFileProvider">Provider used to get data when it is not present on disk</param>
             <param name="statusUpdate">Function used to send status updates</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
             <summary>
             Gets the history for the requested securities
             </summary>
             <param name="requests">The historical data requests</param>
             <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
             <returns>An enumerable of the slices of data covering the span specified in each request</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.CreateSubscription(QuantConnect.Data.HistoryRequest,System.DateTime,System.DateTime)">
             <summary>
             Creates a subscription to process the request
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.HistoricalData.SubscriptionDataReaderHistoryProvider.CreateSliceEnumerableFromSubscriptions(System.Collections.Generic.List{QuantConnect.Lean.Engine.DataFeeds.Subscription},NodaTime.DateTimeZone)">
             <summary>
             Enumerates the subscriptions into slices
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers">
             <summary>
             Provides a container for the algorithm specific handlers
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Results">
             <summary>
             Gets the result handler used to communicate results from the algorithm
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Setup">
             <summary>
             Gets the setup handler used to initialize the algorithm state
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataFeed">
             <summary>
             Gets the data feed handler used to provide data to the algorithm
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Transactions">
             <summary>
             Gets the transaction handler used to process orders from the algorithm
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.RealTime">
             <summary>
             Gets the real time handler used to process real time events
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.CommandQueue">
             <summary>
             Gets the command queue responsible for receiving external commands for the algorithm
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.MapFileProvider">
             <summary>
             Gets the map file provider used as a map file source for the data feed
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.FactorFileProvider">
             <summary>
             Gets the map file provider used as a map file source for the data feed
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.DataFileProvider">
             <summary>
             Gets the data file provider used to retrieve security data if it is not on the file system
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.#ctor(QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.Setup.ISetupHandler,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler,QuantConnect.Interfaces.ICommandQueueHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers" /> class from the specified handlers
             </summary>
             <param name="results">The result handler for communicating results from the algorithm</param>
             <param name="setup">The setup handler used to initialize algorithm state</param>
             <param name="dataFeed">The data feed handler used to pump data to the algorithm</param>
             <param name="transactions">The transaction handler used to process orders from the algorithm</param>
             <param name="realTime">The real time handler used to process real time events</param>
             <param name="commandQueue">The command queue handler used to receive external commands for the algorithm</param>
             <param name="mapFileProvider">The map file provider used to retrieve map files for the data feed</param>
             <param name="factorFileProvider">Map file provider used as a map file source for the data feed</param>
             <param name="dataFileProvider">file provider used to retrieve security data if it is not on the file system</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.FromConfiguration(QuantConnect.Util.Composer)">
             <summary>
             Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers" /> class from the specified composer using type names from configuration
             </summary>
             <param name="composer">The composer instance to obtain implementations from</param>
             <returns>A fully hydrates <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers" /> instance.</returns>
             <exception cref="T:System.ComponentModel.Composition.CompositionException">Throws a CompositionException during failure to load</exception>
            </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers">
             <summary>
             Provides a container for the system level handlers
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Api">
             <summary>
             Gets the api instance used for communicating algorithm limits, status, and storing of log data
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Notify">
             <summary>
             Gets the messaging handler instance used for communicating various packets to listeners, including
             debug/log messages, email/sms/web messages, as well as results and run time errors
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.JobQueue">
             <summary>
             Gets the job queue responsible for acquiring and acknowledging an algorithm job
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.#ctor(QuantConnect.Interfaces.IJobQueueHandler,QuantConnect.Interfaces.IApi,QuantConnect.Interfaces.IMessagingHandler)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers" /> class with the specified handles
             </summary>
             <param name="jobQueue">The job queue used to acquire algorithm jobs</param>
             <param name="api">The api instance used for communicating limits and status</param>
             <param name="notify">The messaging handler user for passing messages from the algorithm to listeners</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.FromConfiguration(QuantConnect.Util.Composer)">
             <summary>
             Creates a new instance of the <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers" /> class from the specified composer using type names from configuration
             </summary>
             <param name="composer">The composer instance to obtain implementations from</param>
             <returns>A fully hydrates <see cref="T:QuantConnect.Lean.Engine.LeanEngineSystemHandlers" /> instance.</returns>
             <exception cref="T:System.ComponentModel.Composition.CompositionException">Throws a CompositionException during failure to load</exception>
            </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Initialize">
             <summary>
             Initializes the Api, Messaging, and JobQueue components
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.LeanEngineSystemHandlers.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler">
             <summary>
             Live trading realtime event processing.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.IsActive">
             <summary>
             Boolean flag indicating thread state.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi)">
             <summary>
             Intializes the real time handler for the specified algorithm and job
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Run">
             <summary>
             Execute the live realtime event thread montioring. 
             It scans every second monitoring for an event trigger.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.RefreshMarketHoursToday(System.DateTime)">
             <summary>
             Refresh the Today variable holding the market hours information
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Add(QuantConnect.Scheduling.ScheduledEvent)">
             <summary>
             Adds the specified event to the schedule
             </summary>
             <param name="scheduledEvent">The event to be scheduled, including the date/times the event fires and the callback</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Remove(System.String)">
             <summary>
             Removes the specified event from the schedule
             </summary>
             <param name="name"></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.SetTime(System.DateTime)">
             <summary>
             Set the current time. If the date changes re-start the realtime event setup routines.
             </summary>
             <param name="time"></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.LiveTradingRealTimeHandler.Exit">
             <summary>
             Stop the real time thread
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler">
             <summary>
             Psuedo realtime event processing for backtesting to simulate realtime events in fast forward.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.IsActive">
             <summary>
             Flag indicating the hander thread is completely finished and ready to dispose.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi)">
             <summary>
             Intializes the real time handler for the specified algorithm and job
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Run">
             <summary>
             Normally this would run the realtime event monitoring. Backtesting is in fastforward so the realtime is linked to the backtest clock.
             This thread does nothing. Wait until the job is over.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Add(QuantConnect.Scheduling.ScheduledEvent)">
             <summary>
             Adds the specified event to the schedule
             </summary>
             <param name="scheduledEvent">The event to be scheduled, including the date/times the event fires and the callback</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Remove(System.String)">
             <summary>
             Removes the specified event from the schedule
             </summary>
             <param name="name">The name of the event to remove</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.SetTime(System.DateTime)">
             <summary>
             Set the time for the realtime event handler.
             </summary>
             <param name="time">Current time.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.BacktestingRealTimeHandler.Exit">
             <summary>
             Stop the real time thread
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler">
             <summary>
             Real time event handler, trigger functions at regular or pretimed intervals
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.IsActive">
             <summary>
             Thread status flag.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IApi)">
             <summary>
             Intializes the real time handler for the specified algorithm and job
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.Run">
             <summary>
             Main entry point to scan and trigger the realtime events.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.SetTime(System.DateTime)">
             <summary>
             Set the current time for the event scanner (so we can use same code for backtesting and live events)
             </summary>
             <param name="time">Current real or backtest time.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.IRealTimeHandler.Exit">
             <summary>
             Trigger and exit signal to terminate real time event scanner.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory">
             <summary>
             Provides methods for creating common scheduled events
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EveryDayAt(System.String,System.Collections.Generic.IEnumerable{System.DateTime},System.TimeSpan,System.Action{System.String,System.DateTime},System.Nullable{System.DateTime})">
             <summary>
             Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent" /> that will fire at the specified <paramref name="timeOfDay" /> for every day in
             <paramref name="dates" />
             </summary>
             <param name="name">An identifier for this event</param>
             <param name="dates">The dates to set events for at the specified time. These act as a base time to which
             the <paramref name="timeOfDay" /> is added to, that is, the implementation does not use .Date before
             the addition</param>
             <param name="timeOfDay">The time each tradeable date to fire the event</param>
             <param name="callback">The delegate to call when an event fires</param>
             <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
             <returns>A new <see cref="T:QuantConnect.Scheduling.ScheduledEvent" /> instance that fires events each tradeable day from the start to the finish at the specified time</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EveryAlgorithmEndOfDay(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,System.DateTime,System.DateTime,System.TimeSpan,System.Nullable{System.DateTime})">
             <summary>
             Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent" /> that will fire before market close by the specified time 
             </summary>
             <param name="algorithm">The algorithm instance the event is fo</param>
             <param name="resultHandler">The result handler, used to communicate run time errors</param>
             <param name="start">The date to start the events</param>
             <param name="end">The date to end the events</param>
             <param name="endOfDayDelta">The time difference between the market close and the event, positive time will fire before market close</param>
             <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
             <returns>The new <see cref="T:QuantConnect.Scheduling.ScheduledEvent" /> that will fire near market close each tradeable dat</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.EverySecurityEndOfDay(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Securities.Security,System.DateTime,System.DateTime,System.TimeSpan,System.Nullable{System.DateTime})">
             <summary>
             Creates a new <see cref="T:QuantConnect.Scheduling.ScheduledEvent" /> that will fire before market close by the specified time 
             </summary>
             <param name="algorithm">The algorithm instance the event is fo</param>
             <param name="resultHandler">The result handler, used to communicate run time errors</param>
             <param name="security">The security used for defining tradeable dates</param>
             <param name="start">The first date for the events</param>
             <param name="end">The date to end the events</param>
             <param name="endOfDayDelta">The time difference between the market close and the event, positive time will fire before market close</param>
             <param name="currentUtcTime">Specfies the current time in UTC, before which, no events will be scheduled. Specify null to skip this filter.</param>
             <returns>The new <see cref="T:QuantConnect.Scheduling.ScheduledEvent" /> that will fire near market close each tradeable dat</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.RealTime.ScheduledEventFactory.CreateEventName(System.String,System.String)">
             <summary>
             Defines the format of event names generated by this system.
             </summary>
             <param name="scope">The scope of the event, example, 'Algorithm' or 'Security'</param>
             <param name="name">A name for this specified event in this scope, example, 'EndOfDay'</param>
             <returns>A string representing a fully scoped event name</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Results.DesktopResultHandler">
             <summary>
             Desktop Result Handler - Desktop GUI Result Handler for Piping Results to WinForms:
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.DesktopResultHandler.FinalStatistics">
             <summary>
             A dictionary containing summary statistics
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.DesktopResultHandler.Messages">
             <summary>
             Messaging to store notification messages for processing.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.DesktopResultHandler.Algorithm">
             <summary>
             Local object access to the algorithm for the underlying Debug and Error messaging.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.DesktopResultHandler.Charts">
             <summary>
             Charts collection for storing the master copy of user charting data.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.DesktopResultHandler.IsActive">
             <summary>
             Boolean flag indicating the result hander thread is busy. 
             False means it has completely finished and ready to dispose.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.DesktopResultHandler.ResamplePeriod">
             <summary>
             Sampling period for timespans between resamples of the charting equity.
             </summary>
             <remarks>Specifically critical for backtesting since with such long timeframes the sampled data can get extreme.</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.DesktopResultHandler.NotificationPeriod">
             <summary>
             How frequently the backtests push messages to the browser.
             </summary>
             <remarks>Update frequency of notification packets</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.#ctor">
             <summary>
             Desktop default constructor
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.Setup.ISetupHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
             <summary>
             Initialize the result handler with this result packet.
             </summary>
             <param name="job">Algorithm job packet for this result handler</param>
             <param name="messagingHandler"></param>
             <param name="api"></param>
             <param name="dataFeed"></param>
             <param name="setupHandler"></param>
             <param name="transactionHandler"></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.Run">
             <summary>
             Entry point for console result handler thread.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.DebugMessage(System.String)">
             <summary>
             Send a debug message back to the browser console.
             </summary>
             <param name="message">Message we'd like shown in console.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.LogMessage(System.String)">
             <summary>
             Send a logging message to the log list for storage.
             </summary>
             <param name="message">Message we'd in the log.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.RuntimeError(System.String,System.String)">
             <summary>
             Send a runtime error message back to the browser highlighted with in red 
             </summary>
             <param name="message">Error message.</param>
             <param name="stacktrace">Stacktrace information string</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.ErrorMessage(System.String)">
             <summary>
             Send an error message back to the console highlighted in red with a stacktrace.
             </summary>
             <param name="message">Error message we'd like shown in console.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.ErrorMessage(System.String,System.String)">
             <summary>
             Send an error message back to the console highlighted in red with a stacktrace.
             </summary>
             <param name="message">Error message we'd like shown in console.</param>
             <param name="stacktrace">Stacktrace information string</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)">
             <summary>
             Add a sample to the chart specified by the chartName, and seriesName.
             </summary>
             <param name="chartName">String chart name to place the sample.</param>
             <param name="seriesIndex">Type of chart we should create if it doesn't already exist.</param>
             <param name="seriesName">Series name for the chart.</param>
             <param name="seriesType">Series type for the chart.</param>
             <param name="time">Time for the sample</param>
             <param name="value">Value for the chart sample.</param>
             <param name="unit">Unit for the sample axis</param>
             <remarks>Sample can be used to create new charts or sample equity - daily performance.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SampleEquity(System.DateTime,System.Decimal)">
             <summary>
             Sample the strategy equity at this moment in time.
             </summary>
             <param name="time">Current time</param>
             <param name="value">Current equity value</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SamplePerformance(System.DateTime,System.Decimal)">
             <summary>
             Sample today's algorithm daily performance value.
             </summary>
             <param name="time">Current time.</param>
             <param name="value">Value of the daily performance.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SampleBenchmark(System.DateTime,System.Decimal)">
             <summary>
             Sample the current benchmark performance directly with a time-value pair.
             </summary>
             <param name="time">Current backtest date.</param>
             <param name="value">Current benchmark value.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
             <summary>
             Analyse the algorithm and determine its security types.
             </summary>
             <param name="types">List of security types in the algorithm</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
             <summary>
             Send an algorithm status update to the browser.
             </summary>
             <param name="status">Status enum value.</param>
             <param name="message">Additional optional status message.</param>
             <remarks>In backtesting we do not send the algorithm status updates.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SampleAssetPrices(QuantConnect.Symbol,System.DateTime,System.Decimal)">
             <summary>
             Sample the asset prices to generate plots.
             </summary>
             <param name="symbol">Symbol we're sampling.</param>
             <param name="time">Time of sample</param>
             <param name="value">Value of the asset price</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SampleRange(System.Collections.Generic.List{QuantConnect.Chart})">
             <summary>
             Add a range of samples to the store.
             </summary>
             <param name="updates">Charting updates since the last sample request.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SendFinalResult(QuantConnect.Packets.AlgorithmNodePacket,System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.DateTime,System.Decimal},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},QuantConnect.Statistics.StatisticsResults,System.Collections.Generic.Dictionary{System.String,System.String})">
             <summary>
             Algorithm final analysis results dumped to the console.
             </summary>
             <param name="job">Lean AlgorithmJob task</param>
             <param name="orders">Collection of orders from the algorithm</param>
             <param name="profitLoss">Collection of time-profit values for the algorithm</param>
             <param name="holdings">Current holdings state for the algorithm</param>
             <param name="statisticsResults">Statistics information for the algorithm (empty if not finished)</param>
             <param name="banner">Runtime statistics banner information</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
             <summary>
             Set the Algorithm instance for ths result.
             </summary>
             <param name="algorithm">Algorithm we're working on.</param>
             <remarks>While setting the algorithm the backtest result handler.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.Exit">
             <summary>
             Terminate the result thread and apply any required exit proceedures.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
             <summary>
             Send a new order event to the browser.
             </summary>
             <remarks>In backtesting the order events are not sent because it would generate a high load of messaging.</remarks>
             <param name="newEvent">New order event details</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.RuntimeStatistic(System.String,System.String)">
             <summary>
             Set the current runtime statistics of the algorithm
             </summary>
             <param name="key">Runtime headline statistic name</param>
             <param name="value">Runtime headline statistic value</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.PurgeQueue">
             <summary>
             Clear the outstanding message queue to exit the thread.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.StoreResult(QuantConnect.Packets.Packet,System.Boolean)">
             <summary>
             Store result on desktop.
             </summary>
             <param name="packet">Packet of data to store.</param>
             <param name="async">Store the packet asyncronously to speed up the thread.</param>
             <remarks>Async creates crashes in Mono 3.10 if the thread disappears before the upload is complete so it is disabled for now.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.SetChartSubscription(System.String)">
             <summary>
             Not used
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.DesktopResultHandler.ProcessSynchronousEvents(System.Boolean)">
             <summary>
             Process the synchronous result events, sampling and message reading. 
             This method is triggered from the algorithm manager thread.
             </summary>
             <remarks>Prime candidate for putting into a base class. Is identical across all result handlers.</remarks>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Results.IResultHandler">
             <summary>
             Handle the results of the backtest: where should we send the profit, portfolio updates:
             Backtester or the Live trading platform:
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.Messages">
             <summary>
             Put messages to process into the queue so they are processed by this thread.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.Charts">
             <summary>
             Charts collection for storing the master copy of user charting data.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.ResamplePeriod">
             <summary>
             Sampling period for timespans between resamples of the charting equity.
             </summary>
             <remarks>Specifically critical for backtesting since with such long timeframes the sampled data can get extreme.</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.NotificationPeriod">
             <summary>
             How frequently the backtests push messages to the browser.
             </summary>
             <remarks>Update frequency of notification packets</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.IResultHandler.IsActive">
             <summary>
             Boolean flag indicating the result hander thread is busy. 
             False means it has completely finished and ready to dispose.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.Setup.ISetupHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
             <summary>
             Initialize the result handler with this result packet.
             </summary>
             <param name="job">Algorithm job packet for this result handler</param>
             <param name="messagingHandler"></param>
             <param name="api"></param>
             <param name="dataFeed"></param>
             <param name="setupHandler"></param>
             <param name="transactionHandler"></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Run">
             <summary>
             Primary result thread entry point to process the result message queue and send it to whatever endpoint is set.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.DebugMessage(System.String)">
             <summary>
             Process debug messages with the preconfigured settings.
             </summary>
             <param name="message">String debug message</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
             <summary>
             Send a list of security types to the browser
             </summary>
             <param name="types">Security types list inside algorithm</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.LogMessage(System.String)">
             <summary>
             Send a logging message to the log list for storage.
             </summary>
             <param name="message">Message we'd in the log.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.ErrorMessage(System.String,System.String)">
             <summary>
             Send an error message back to the browser highlighted in red with a stacktrace.
             </summary>
             <param name="error">Error message we'd like shown in console.</param>
             <param name="stacktrace">Stacktrace information string</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.RuntimeError(System.String,System.String)">
             <summary>
             Send a runtime error message back to the browser highlighted with in red 
             </summary>
             <param name="message">Error message.</param>
             <param name="stacktrace">Stacktrace information string</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)">
             <summary>
             Add a sample to the chart specified by the chartName, and seriesName.
             </summary>
             <param name="chartName">String chart name to place the sample.</param>
             <param name="seriesName">Series name for the chart.</param>
             <param name="seriesType">Series type for the chart.</param>
             <param name="time">Time for the sample</param>
             <param name="value">Value for the chart sample.</param>
             <param name="unit">Unit for the sample chart</param>
             <param name="seriesIndex">Index of the series we're sampling</param>
             <remarks>Sample can be used to create new charts or sample equity - daily performance.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SampleEquity(System.DateTime,System.Decimal)">
             <summary>
             Wrapper methond on sample to create the equity chart.
             </summary>
             <param name="time">Time of the sample.</param>
             <param name="value">Equity value at this moment in time.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SamplePerformance(System.DateTime,System.Decimal)">
             <summary>
             Sample the current daily performance directly with a time-value pair.
             </summary>
             <param name="time">Current backtest date.</param>
             <param name="value">Current daily performance value.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SampleBenchmark(System.DateTime,System.Decimal)">
             <summary>
             Sample the current benchmark performance directly with a time-value pair.
             </summary>
             <param name="time">Current backtest date.</param>
             <param name="value">Current benchmark value.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SampleAssetPrices(QuantConnect.Symbol,System.DateTime,System.Decimal)">
             <summary>
             Sample the asset prices to generate plots.
             </summary>
             <param name="symbol">Symbol we're sampling.</param>
             <param name="time">Time of sample</param>
             <param name="value">Value of the asset price</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SampleRange(System.Collections.Generic.List{QuantConnect.Chart})">
             <summary>
             Add a range of samples from the users algorithms to the end of our current list.
             </summary>
             <param name="samples">Chart updates since the last request.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
             <summary>
             Set the algorithm of the result handler after its been initialized.
             </summary>
             <param name="algorithm">Algorithm object matching IAlgorithm interface</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.StoreResult(QuantConnect.Packets.Packet,System.Boolean)">
             <summary>
             Save the snapshot of the total results to storage.
             </summary>
             <param name="packet">Packet to store.</param>
             <param name="async">Store the packet asyncronously to speed up the thread.</param>
             <remarks>Async creates crashes in Mono 3.10 if the thread disappears before the upload is complete so it is disabled for now.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SendFinalResult(QuantConnect.Packets.AlgorithmNodePacket,System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.DateTime,System.Decimal},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},QuantConnect.Statistics.StatisticsResults,System.Collections.Generic.Dictionary{System.String,System.String})">
             <summary>
             Post the final result back to the controller worker if backtesting, or to console if local.
             </summary>
             <param name="job">Lean AlgorithmJob task</param>
             <param name="orders">Collection of orders from the algorithm</param>
             <param name="profitLoss">Collection of time-profit values for the algorithm</param>
             <param name="holdings">Current holdings state for the algorithm</param>
             <param name="statisticsResults">Statistics information for the algorithm (empty if not finished)</param>
             <param name="banner">Runtime statistics banner information</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
             <summary>
             Send a algorithm status update to the user of the algorithms running state.
             </summary>
             <param name="status">Status enum of the algorithm.</param>
             <param name="message">Optional string message describing reason for status change.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.SetChartSubscription(System.String)">
             <summary>
             Set the chart name:
             </summary>
             <param name="symbol">Symbol of the chart we want.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.RuntimeStatistic(System.String,System.String)">
             <summary>
             Set a dynamic runtime statistic to show in the (live) algorithm header
             </summary>
             <param name="key">Runtime headline statistic name</param>
             <param name="value">Runtime headline statistic value</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
             <summary>
             Send a new order event.
             </summary>
             <param name="newEvent">Update, processing or cancellation of an order, update the IDE in live mode or ignore in backtesting.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.Exit">
             <summary>
             Terminate the result thread and apply any required exit proceedures.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.PurgeQueue">
             <summary>
             Purge/clear any outstanding messages in message queue.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.IResultHandler.ProcessSynchronousEvents(System.Boolean)">
             <summary>
             Process any synchronous events in here that are primarily triggered from the algorithm loop
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler">
             <summary>
             Defines a set up handler that initializes the algorithm instance using values retrieved from the user's brokerage account
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Errors">
             <summary>
             Any errors from the initialization stored here:
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.MaximumRuntime">
             <summary>
             Get the maximum runtime for this algorithm job.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.StartingPortfolioValue">
             <summary>
             Algorithm starting capital for statistics calculations
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.StartingDate">
             <summary>
             Start date for analysis loops to search for data.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.MaxOrders">
             <summary>
             Maximum number of orders for the algorithm run -- applicable for backtests only.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.#ctor">
             <summary>
             Initializes a new BrokerageSetupHandler
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.CreateAlgorithmInstance(System.String,QuantConnect.Language)">
             <summary>
             Create a new instance of an algorithm from a physical dll path.
             </summary>
             <param name="assemblyPath">The path to the assembly's location</param>
             <param name="language">The algorithm's language</param>
             <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
             <summary>
             Creates the brokerage as specified by the job packet
             </summary>
             <param name="algorithmNodePacket">Job packet</param>
             <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
             <param name="factory">The brokerage factory</param>
             <returns>The brokerage instance, or throws if error creating instance</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler)">
             <summary>
             Primary entry point to setup a new algorithm
             </summary>
             <param name="algorithm">Algorithm instance</param>
             <param name="brokerage">New brokerage output instance</param>
             <param name="job">Algorithm job task</param>
             <param name="resultHandler">The configured result handler</param>
             <param name="transactionHandler">The configurated transaction handler</param>
             <param name="realTimeHandler">The configured real time handler</param>
             <returns>True on successfully setting up the algorithm state, or false on error.</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.GetConfiguredDataFeeds">
             <summary>
             Get the available data feeds from config.json,
             If none available, throw an error
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.AddInitializationError(System.String)">
             <summary>
             Adds initializaion error to the Errors list
             </summary>
             <param name="message">The error message to be added</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BrokerageSetupHandler.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.StateCheck">
             <summary>
             Algorithm status monitor reads the central command directive for this algorithm/backtest. When it detects
             the backtest has been deleted or cancelled the backtest is aborted.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.StateCheck.Ping">
             DB Ping Class
            </member>
        <member name="M:QuantConnect.Lean.Engine.StateCheck.Ping.#ctor(QuantConnect.Lean.Engine.AlgorithmManager,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Packets.AlgorithmNodePacket)">
             <summary>
             Creates an instance of the <see cref="T:QuantConnect.Lean.Engine.StateCheck.Ping" /> class
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.StateCheck.Ping.Run">
             DB Ping Run Method:
            </member>
        <member name="M:QuantConnect.Lean.Engine.StateCheck.Ping.Exit">
             <summary>
             Send an exit signal to the thread
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler">
             <summary>
             Console setup handler to initialize and setup the Lean Engine properties for a local backtest
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.Errors">
             <summary>
             Error which occured during setup may appear here.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.MaximumRuntime">
             <summary>
             Maximum runtime of the strategy. (Set to 10 years for local backtesting).
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.StartingPortfolioValue">
             <summary>
             Starting capital for the algorithm (Loaded from the algorithm code).
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.StartingDate">
             <summary>
             Start date for the backtest.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.MaxOrders">
             <summary>
             Maximum number of orders for this backtest.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.#ctor">
             <summary>
             Setup the algorithm data, cash, job start end date etc:
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.CreateAlgorithmInstance(System.String,QuantConnect.Language)">
             <summary>
             Creates a new algorithm instance. Checks configuration for a specific type name, and if present will
             force it to find that one
             </summary>
             <param name="assemblyPath">Physical path of the algorithm dll.</param>
             <param name="language">Language of the assembly.</param>
             <returns>Algorithm instance</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
             <summary>
             Creates a new <see cref="T:QuantConnect.Brokerages.Backtesting.BacktestingBrokerage" /> instance
             </summary>
             <param name="algorithmNodePacket">Job packet</param>
             <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
             <returns>The brokerage instance, or throws if error creating instance</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler)">
             <summary>
             Setup the algorithm cash, dates and portfolio as desired.
             </summary>
             <param name="algorithm">Existing algorithm instance</param>
             <param name="brokerage">New brokerage instance</param>
             <param name="baseJob">Backtesting job</param>
             <param name="resultHandler">The configured result handler</param>
             <param name="transactionHandler">The configuration transaction handler</param>
             <param name="realTimeHandler">The configured real time handler</param>
             <returns>Boolean true on successfully setting up the console.</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.GetConfiguredDataFeeds">
             <summary>
             Get the available data feeds from config.json,
             If none available, throw an error
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.MatchTypeName(System.String,System.String)">
             <summary>
             Matches type names as namespace qualified or just the name
             If expectedTypeName is null or empty, this will always return true
             </summary>
             <param name="currentTypeFullName"></param>
             <param name="expectedTypeName"></param>
             <returns>True on matching the type name</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ConsoleSetupHandler.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler">
             <summary>
             Backtesting setup handler processes the algorithm initialize method and sets up the internal state of the algorithm class.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Errors">
             <summary>
             Internal errors list from running the setup proceedures.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.MaximumRuntime">
             <summary>
             Maximum runtime of the algorithm in seconds.
             </summary>
             <remarks>Maximum runtime is a formula based on the number and resolution of symbols requested, and the days backtesting</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.StartingPortfolioValue">
             <summary>
             Starting capital according to the users initialize routine.
             </summary>
             <remarks>Set from the user code.</remarks>
             <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.SetCash(System.Decimal)" />
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.StartingDate">
             <summary>
             Start date for analysis loops to search for data.
             </summary>
             <seealso cref="M:QuantConnect.Algorithm.QCAlgorithm.SetStartDate(System.DateTime)" />
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.MaxOrders">
             <summary>
             Maximum number of orders for this backtest.
             </summary>
             <remarks>To stop algorithm flooding the backtesting system with hundreds of megabytes of order data we limit it to 100 per day</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.#ctor">
             <summary>
             Initialize the backtest setup handler.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.CreateAlgorithmInstance(System.String,QuantConnect.Language)">
             <summary>
             Creates a new algorithm instance. Verified there's only one defined in the assembly and requires
             instantiation to take less than 10 seconds
             </summary>
             <param name="assemblyPath">Physical location of the assembly.</param>
             <param name="language">Language of the DLL</param>
             <returns>Algorithm instance.</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
             <summary>
             Creates a new <see cref="T:QuantConnect.Brokerages.Backtesting.BacktestingBrokerage" /> instance
             </summary>
             <param name="algorithmNodePacket">Job packet</param>
             <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
             <returns>The brokerage instance, or throws if error creating instance</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler)">
             <summary>
             Setup the algorithm cash, dates and data subscriptions as desired.
             </summary>
             <param name="algorithm">Algorithm instance</param>
             <param name="brokerage">Brokerage instance</param>
             <param name="baseJob">Algorithm job</param>
             <param name="resultHandler">The configured result handler</param>
             <param name="transactionHandler">The configurated transaction handler</param>
             <param name="realTimeHandler">The configured real time handler</param>
             <returns>Boolean true on successfully initializing the algorithm</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.GetMaximumRuntime(System.DateTime,System.DateTime,QuantConnect.Data.SubscriptionManager,QuantConnect.Packets.Controls)">
             <summary>
             Calculate the maximum runtime for this algorithm job.
             </summary>
             <param name="start">State date of the algorithm</param>
             <param name="finish">End date of the algorithm</param>
             <param name="subscriptionManager">Subscription Manager</param>
             <param name="controls">Job controls instance</param>
             <returns>Timespan maximum run period</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.BacktestingSetupHandler.Dispose">
             <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
             </summary>
             <filterpriority>2</filterpriority>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Setup.ISetupHandler">
             <summary>
             Interface to setup the algorithm. Pass in a raw algorithm, return one with portfolio, cash, etc already preset.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.Errors">
             <summary>
             Any errors from the initialization stored here:
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.MaximumRuntime">
             <summary>
             Get the maximum runtime for this algorithm job.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.StartingPortfolioValue">
             <summary>
             Algorithm starting capital for statistics calculations
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.StartingDate">
             <summary>
             Start date for analysis loops to search for data.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Setup.ISetupHandler.MaxOrders">
             <summary>
             Maximum number of orders for the algorithm run -- applicable for backtests only.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.CreateAlgorithmInstance(System.String,QuantConnect.Language)">
             <summary>
             Create a new instance of an algorithm from a physical dll path.
             </summary>
             <param name="assemblyPath">The path to the assembly's location</param>
             <param name="language">Language of the assembly.</param>
             <returns>A new instance of IAlgorithm, or throws an exception if there was an error</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.CreateBrokerage(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerageFactory@)">
             <summary>
             Creates the brokerage as specified by the job packet
             </summary>
             <param name="algorithmNodePacket">Job packet</param>
             <param name="uninitializedAlgorithm">The algorithm instance before Initialize has been called</param>
             <param name="factory">The brokerage factory</param>
             <returns>The brokerage instance, or throws if error creating instance</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Setup.ISetupHandler.Setup(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler,QuantConnect.Lean.Engine.RealTime.IRealTimeHandler)">
             <summary>
             Primary entry point to setup a new algorithm
             </summary>
             <param name="algorithm">Algorithm instance</param>
             <param name="brokerage">New brokerage output instance</param>
             <param name="job">Algorithm job task</param>
             <param name="resultHandler">The configured result handler</param>
             <param name="transactionHandler">The configurated transaction handler</param>
             <param name="realTimeHandler">The configured real time handler</param>
             <returns>True on successfully setting up the algorithm state, or false on error.</returns>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Results.BacktestingResultHandler">
             <summary>
             Backtesting result handler passes messages back from the Lean to the User.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Messages">
             <summary>
             Packeting message queue to temporarily store packets and then pull for processing.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Algorithm">
             <summary>
             Local object access to the algorithm for the underlying Debug and Error messaging.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Charts">
             <summary>
             Charts collection for storing the master copy of user charting data.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.IsActive">
             <summary>
             Boolean flag indicating the result hander thread is completely finished and ready to dispose.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ResamplePeriod">
             <summary>
             Sampling period for timespans between resamples of the charting equity.
             </summary>
             <remarks>Specifically critical for backtesting since with such long timeframes the sampled data can get extreme.</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.NotificationPeriod">
             <summary>
             How frequently the backtests push messages to the browser.
             </summary>
             <remarks>Update frequency of notification packets</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.FinalStatistics">
             <summary>
             A dictionary containing summary statistics
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.#ctor">
             <summary>
             Default initializer for 
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.Setup.ISetupHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
             <summary>
             Initialize the result handler with this result packet.
             </summary>
             <param name="job">Algorithm job packet for this result handler</param>
             <param name="messagingHandler">The handler responsible for communicating messages to listeners</param>
             <param name="api">The api instance used for handling logs</param>
             <param name="dataFeed"></param>
             <param name="setupHandler"></param>
             <param name="transactionHandler"></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Run">
             <summary>
             The main processing method steps through the messaging queue and processes the messages one by one.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Update">
             <summary>
             Send a backtest update to the browser taking a latest snapshot of the charting data.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SplitPackets(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.String,System.String},System.Decimal)">
             <summary>
             Run over all the data and break it into smaller packets to ensure they all arrive at the terminal
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.StoreResult(QuantConnect.Packets.Packet,System.Boolean)">
             <summary>
             Save the snapshot of the total results to storage.
             </summary>
             <param name="packet">Packet to store.</param>
             <param name="async">Store the packet asyncronously to speed up the thread.</param>
             <remarks>Async creates crashes in Mono 3.10 if the thread disappears before the upload is complete so it is disabled for now.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SendFinalResult(QuantConnect.Packets.AlgorithmNodePacket,System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.DateTime,System.Decimal},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},QuantConnect.Statistics.StatisticsResults,System.Collections.Generic.Dictionary{System.String,System.String})">
             <summary>
             Send a final analysis result back to the IDE.
             </summary>
             <param name="job">Lean AlgorithmJob task</param>
             <param name="orders">Collection of orders from the algorithm</param>
             <param name="profitLoss">Collection of time-profit values for the algorithm</param>
             <param name="holdings">Current holdings state for the algorithm</param>
             <param name="statisticsResults">Statistics information for the algorithm (empty if not finished)</param>
             <param name="banner">Runtime statistics banner information</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
             <summary>
             Set the Algorithm instance for ths result.
             </summary>
             <param name="algorithm">Algorithm we're working on.</param>
             <remarks>While setting the algorithm the backtest result handler.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.DebugMessage(System.String)">
             <summary>
             Send a debug message back to the browser console.
             </summary>
             <param name="message">Message we'd like shown in console.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.LogMessage(System.String)">
             <summary>
             Send a logging message to the log list for storage.
             </summary>
             <param name="message">Message we'd in the log.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
             <summary>
             Send list of security asset types the algortihm uses to browser.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ErrorMessage(System.String,System.String)">
             <summary>
             Send an error message back to the browser highlighted in red with a stacktrace.
             </summary>
             <param name="message">Error message we'd like shown in console.</param>
             <param name="stacktrace">Stacktrace information string</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.RuntimeError(System.String,System.String)">
             <summary>
             Send a runtime error message back to the browser highlighted with in red 
             </summary>
             <param name="message">Error message.</param>
             <param name="stacktrace">Stacktrace information string</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)">
             <summary>
             Add a sample to the chart specified by the chartName, and seriesName.
             </summary>
             <param name="chartName">String chart name to place the sample.</param>
             <param name="seriesIndex">Type of chart we should create if it doesn't already exist.</param>
             <param name="seriesName">Series name for the chart.</param>
             <param name="seriesType">Series type for the chart.</param>
             <param name="time">Time for the sample</param>
             <param name="unit">Unit of the sample</param>
             <param name="value">Value for the chart sample.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleEquity(System.DateTime,System.Decimal)">
             <summary>
             Sample the current equity of the strategy directly with time-value pair.
             </summary>
             <param name="time">Current backtest time.</param>
             <param name="value">Current equity value.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SamplePerformance(System.DateTime,System.Decimal)">
             <summary>
             Sample the current daily performance directly with a time-value pair.
             </summary>
             <param name="time">Current backtest date.</param>
             <param name="value">Current daily performance value.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleBenchmark(System.DateTime,System.Decimal)">
             <summary>
             Sample the current benchmark performance directly with a time-value pair.
             </summary>
             <param name="time">Current backtest date.</param>
             <param name="value">Current benchmark value.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleRange(System.Collections.Generic.List{QuantConnect.Chart})">
             <summary>
             Add a range of samples from the users algorithms to the end of our current list.
             </summary>
             <param name="updates">Chart updates since the last request.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.Exit">
             <summary>
             Terminate the result thread and apply any required exit procedures.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
             <summary>
             Send a new order event to the browser.
             </summary>
             <remarks>In backtesting the order events are not sent because it would generate a high load of messaging.</remarks>
             <param name="newEvent">New order event details</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
             <summary>
             Send an algorithm status update to the browser.
             </summary>
             <param name="status">Status enum value.</param>
             <param name="message">Additional optional status message.</param>
             <remarks>In backtesting we do not send the algorithm status updates.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SampleAssetPrices(QuantConnect.Symbol,System.DateTime,System.Decimal)">
             <summary>
             Sample the asset prices to generate plots.
             </summary>
             <param name="symbol">Symbol we're sampling.</param>
             <param name="time">Time of sample</param>
             <param name="value">Value of the asset price</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.PurgeQueue">
             <summary>
             Purge/clear any outstanding messages in message queue.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.RuntimeStatistic(System.String,System.String)">
             <summary>
             Set the current runtime statistics of the algorithm. 
             These are banner/title statistics which show at the top of the live trading results.
             </summary>
             <param name="key">Runtime headline statistic name</param>
             <param name="value">Runtime headline statistic value</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ProcessLogMessages(QuantConnect.Packets.AlgorithmNodePacket)">
             <summary>
             Process log messages and return a string indicating the location of the logs
             </summary>
             <param name="job">Algorithm job/task packet</param>
             <returns>String URL of log</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.SetChartSubscription(System.String)">
             <summary>
             Set the chart subscription we want data for. Not used in backtesting.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.BacktestingResultHandler.ProcessSynchronousEvents(System.Boolean)">
             <summary>
             Process the synchronous result events, sampling and message reading. 
             This method is triggered from the algorithm manager thread.
             </summary>
             <remarks>Prime candidate for putting into a base class. Is identical across all result handlers.</remarks>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed">
             <summary>
             Historical datafeed stream reader for processing files on a local disk.
             </summary>
             <remarks>Filesystem datafeeds are incredibly fast</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Subscriptions">
             <summary>
             Gets all of the current subscriptions this data feed is processing
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.IsActive">
             <summary>
             Flag indicating the hander thread is completely finished and ready to dispose.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Initializes the data feed for the specified job and algorithm
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.AddSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
             <summary>
             Adds a new subscription to provide data for the specified security.
             </summary>
             <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
             <returns>True if the subscription was created and added successfully, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.RemoveSubscription(QuantConnect.Data.SubscriptionDataConfig)">
             <summary>
             Removes the subscription from the data feed, if it exists
             </summary>
             <param name="configuration">The configuration of the subscription to remove</param>
             <returns>True if the subscription was successfully removed, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Run">
             <summary>
             Main routine for datafeed analysis.
             </summary>
             <remarks>This is a hot-thread and should be kept extremely lean. Modify with caution.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.CreateUniverseSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
             <summary>
             Adds a new subscription for universe selection
             </summary>
             <param name="request">The subscription request</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.GetEnumeratorFactory(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
             <summary>
             Creates the correct enumerator factory for the given request
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.Exit">
             <summary>
             Send an exit signal to the thread.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.UpdateFillForwardResolution">
             <summary>
             Updates the fill forward resolution by checking all existing subscriptions and
             selecting the smallest resoluton not equal to tick
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.GetEnumerator">
             <summary>
             Returns an enumerator that iterates through the collection.
             </summary>
             <returns>
             A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
             </returns>
             <filterpriority>1</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.System#Collections#IEnumerable#GetEnumerator">
             <summary>
             Returns an enumerator that iterates through a collection.
             </summary>
             <returns>
             An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
             </returns>
             <filterpriority>2</filterpriority>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.FileSystemDataFeed.ConfigureEnumerator(QuantConnect.Data.UniverseSelection.SubscriptionRequest,System.Boolean,System.Collections.Generic.IEnumerator{QuantConnect.Data.BaseData})">
             <summary>
             Configure the enumerator with aggregation/fill-forward/filter behaviors. Returns new instance if re-configured
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler">
             <summary>
             This transaction handler is used for processing transactions during backtests
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
             <summary>
             Creates a new BacktestingTransactionHandler using the BacktestingBrokerage
             </summary>
             <param name="algorithm">The algorithm instance</param>
             <param name="brokerage">The BacktestingBrokerage</param>
             <param name="resultHandler"></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessSynchronousEvents">
             <summary>
             Processes all synchronous events that must take place before the next time loop for the algorithm
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BacktestingTransactionHandler.ProcessAsynchronousEvents">
             <summary>
             Processes asynchronous events on the transaction handler's thread
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler">
             <summary>
             Transaction handler for all brokerages
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._orderRequestQueue">
             <summary>
             OrderQueue holds the newly updated orders from the user algorithm waiting to be processed. Once
             orders are processed they are moved into the Orders queue awaiting the brokerage response.
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._orders">
             <summary>
             The orders dictionary holds orders which are sent to exchange, partially filled, completely filled or cancelled.
             Once the transaction thread has worked on them they get put here while witing for fill updates.
             </summary>
            </member>
        <member name="F:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler._orderTickets">
             <summary>
             The orders tickets dictionary holds order tickets that the algorithm can use to reference a specific order. This
             includes invoking update and cancel commands. In the future, we can add more features to the ticket, such as events
             and async events (such as run this code when this order fills)
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Orders">
             <summary>
             Gets the permanent storage for all orders
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.OrdersCount">
             <summary>
             Gets the current number of orders that have been processed
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
             <summary>
             Creates a new BrokerageTransactionHandler to process orders using the specified brokerage implementation
             </summary>
             <param name="algorithm">The algorithm instance</param>
             <param name="brokerage">The brokerage implementation to process orders and fire fill events</param>
             <param name="resultHandler"></param>
            </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.IsActive">
             <summary>
             Boolean flag indicating the Run thread method is busy. 
             False indicates it is completely finished processing and ready to be terminated.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Process(QuantConnect.Orders.OrderRequest)">
             <summary>
             Adds the specified order to be processed
             </summary>
             <param name="request">The order to be processed</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.AddOrder(QuantConnect.Orders.SubmitOrderRequest)">
             <summary>
             Add an order to collection and return the unique order id or negative if an error.
             </summary>
             <param name="request">A request detailing the order to be submitted</param>
             <returns>New unique, increasing orderid</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.UpdateOrder(QuantConnect.Orders.UpdateOrderRequest)">
             <summary>
             Update an order yet to be filled such as stop or limit orders.
             </summary>
             <param name="request">Request detailing how the order should be updated</param>
             <remarks>Does not apply if the order is already fully filled</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.CancelOrder(QuantConnect.Orders.CancelOrderRequest)">
             <summary>
             Remove this order from outstanding queue: user is requesting a cancel.
             </summary>
             <param name="request">Request containing the specific order id to remove</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderTickets(System.Func{QuantConnect.Orders.OrderTicket,System.Boolean})">
             <summary>
             Gets and enumerable of <see cref="T:QuantConnect.Orders.OrderTicket" /> matching the specified <paramref name="filter" />
             </summary>
             <param name="filter">The filter predicate used to find the required order tickets</param>
             <returns>An enumerable of <see cref="T:QuantConnect.Orders.OrderTicket" /> matching the specified <paramref name="filter" /></returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderTicket(System.Int32)">
             <summary>
             Gets the order ticket for the specified order id. Returns null if not found
             </summary>
             <param name="orderId">The order's id</param>
             <returns>The order ticket with the specified id, or null if not found</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderById(System.Int32)">
             <summary>
             Get the order by its id
             </summary>
             <param name="orderId">Order id to fetch</param>
             <returns>The order with the specified id, or null if no match is found</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrderByBrokerageId(System.String)">
             <summary>
             Gets the order by its brokerage id
             </summary>
             <param name="brokerageId">The brokerage id to fetch</param>
             <returns>The first order matching the brokerage id, or null if no match is found</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.GetOrders(System.Func{QuantConnect.Orders.Order,System.Boolean})">
             <summary>
             Gets all orders matching the specified filter
             </summary>
             <param name="filter">Delegate used to filter the orders</param>
             <returns>All open orders this order provider currently holds</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Run">
             <summary>
             Primary thread entry point to launch the transaction thread.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.ProcessAsynchronousEvents">
             <summary>
             Processes asynchronous events on the transaction handler's thread
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.ProcessSynchronousEvents">
             <summary>
             Processes all synchronous events that must take place before the next time loop for the algorithm
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.PerformCashSync">
             <summary>
             Syncs cash from brokerage with portfolio object
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.Exit">
             <summary>
             Signal a end of thread request to stop montioring the transactions.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleOrderRequest(QuantConnect.Orders.OrderRequest)">
             <summary>
             Handles a generic order request
             </summary>
             <param name="request"><see cref="T:QuantConnect.Orders.OrderRequest" /> to be handled</param>
             <returns><see cref="T:QuantConnect.Orders.OrderResponse" /> for request</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleSubmitOrderRequest(QuantConnect.Orders.SubmitOrderRequest)">
             <summary>
             Handles a request to submit a new order
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleUpdateOrderRequest(QuantConnect.Orders.UpdateOrderRequest)">
             <summary>
             Handles a request to update order properties
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.CanUpdateOrder(QuantConnect.Orders.Order)">
             <summary>
             Returns true if the specified order can be updated
             </summary>
             <param name="order">The order to check if we can update</param>
             <returns>True if the order can be updated, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleCancelOrderRequest(QuantConnect.Orders.CancelOrderRequest)">
             <summary>
             Handles a request to cancel an order
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.HandleAccountChanged(QuantConnect.Securities.AccountEvent)">
             <summary>
             Brokerages can send account updates, this include cash balance updates. Since it is of
             utmost important to always have an accurate picture of reality, we'll trust this information
             as truth
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.TimeSinceLastFill">
             <summary>
             Gets the amount of time since the last call to algorithm.Portfolio.ProcessFill(fill)
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.LastSyncDate">
             <summary>
             Gets the date of the last sync
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.RoundOffOrder(QuantConnect.Orders.Order,QuantConnect.Securities.Security)">
             <summary>
             Rounds off the order towards 0 to the nearest multiple of Lot Size
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.BrokerageTransactionHandler.RoundOrderPrices(QuantConnect.Orders.Order,QuantConnect.Securities.Security)">
             <summary>
             Rounds the order prices to its security minimum price variation.
             <remarks>
             This procedure is needed to meet brokerage precision requirements.
             </remarks>
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler">
             <summary>
             Transaction handlers define how the transactions are processed and set the order fill information.
             The pass this information back to the algorithm portfolio and ensure the cash and portfolio are synchronized.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.IsActive">
             <summary>
             Boolean flag indicating the thread is busy. 
             False indicates it is completely finished processing and ready to be terminated.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Orders">
             <summary>
             Gets the permanent storage for all orders
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Interfaces.IBrokerage,QuantConnect.Lean.Engine.Results.IResultHandler)">
             <summary>
             Initializes the transaction handler for the specified algorithm using the specified brokerage implementation
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Run">
             <summary>
             Primary thread entry point to launch the transaction thread.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.Exit">
             <summary>
             Signal a end of thread request to stop montioring the transactions.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler.ProcessSynchronousEvents">
             <summary>
             Process any synchronous events from the primary algorithm thread.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.DataFeeds.IDataFeed">
             <summary>
             Datafeed interface for creating custom datafeed sources.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Subscriptions">
             <summary>
             Gets all of the current subscriptions this data feed is processing
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.IsActive">
             <summary>
             Public flag indicator that the thread is still busy.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Initialize(QuantConnect.Interfaces.IAlgorithm,QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Lean.Engine.Results.IResultHandler,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,QuantConnect.Interfaces.IDataFileProvider)">
             <summary>
             Initializes the data feed for the specified job and algorithm
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.AddSubscription(QuantConnect.Data.UniverseSelection.SubscriptionRequest)">
             <summary>
             Adds a new subscription to provide data for the specified security.
             </summary>
             <param name="request">Defines the subscription to be added, including start/end times the universe and security</param>
             <returns>True if the subscription was created and added successfully, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.RemoveSubscription(QuantConnect.Data.SubscriptionDataConfig)">
             <summary>
             Removes the subscription from the data feed, if it exists
             </summary>
             <param name="configuration">The configuration of the subscription to remove</param>
             <returns>True if the subscription was successfully removed, false otherwise</returns>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Run">
             <summary>
             Primary entry point.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.DataFeeds.IDataFeed.Exit">
             <summary>
             External controller calls to signal a terminate of the thread.
             </summary>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler">
             <summary>
             Live trading result handler implementation passes the messages to the QC live trading interface.
             </summary>
             <remarks>Live trading result handler is quite busy. It sends constant price updates, equity updates and order/holdings updates.</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Messages">
             <summary>
             Live packet messaging queue. Queue the messages here and send when the result queue is ready.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Charts">
             <summary>
             Storage for the price and equity charts of the live results.
             </summary>
             <remarks>
                 Potential memory leak when the algorithm has been running for a long time. Infinitely storing the results isn't wise.
                 The results should be stored to disk daily, and then the caches reset.
             </remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.IsActive">
             <summary>
             Boolean flag indicating the thread is still active.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.ResamplePeriod">
             <summary>
             Equity resampling period for the charting.
             </summary>
             <remarks>Live trading can resample at much higher frequencies (every 1-2 seconds)</remarks>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.NotificationPeriod">
             <summary>
             Notification periods set how frequently we push updates to the browser.
             </summary>
             <remarks>Live trading resamples - sends updates at high frequencies(every 1-2 seconds)</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.#ctor">
             <summary>
             Initialize the live trading result handler
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMessagingHandler,QuantConnect.Interfaces.IApi,QuantConnect.Lean.Engine.DataFeeds.IDataFeed,QuantConnect.Lean.Engine.Setup.ISetupHandler,QuantConnect.Lean.Engine.TransactionHandlers.ITransactionHandler)">
             <summary>
             Initialize the result handler with this result packet.
             </summary>
             <param name="job">Algorithm job packet for this result handler</param>
             <param name="messagingHandler"></param>
             <param name="api"></param>
             <param name="dataFeed"></param>
             <param name="setupHandler"></param>
             <param name="transactionHandler"></param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Run">
             <summary>
             Live trading result handler thread.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Update">
             <summary>
             Every so often send an update to the browser with the current state of the algorithm.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SplitPackets(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String})">
             <summary>
             Run over all the data and break it into smaller packets to ensure they all arrive at the terminal
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.DebugMessage(System.String)">
             <summary>
             Send a live trading debug message to the live console.
             </summary>
             <param name="message">Message we'd like shown in console.</param>
             <remarks>When there are already 500 messages in the queue it stops adding new messages.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.LogMessage(System.String)">
             <summary>
             Log string messages and send them to the console.
             </summary>
             <param name="message">String message wed like logged.</param>
             <remarks>When there are already 500 messages in the queue it stops adding new messages.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.AddToLogStore(System.String)">
             <summary>
             Save an algorithm message to the log store. Uses a different timestamped method of adding messaging to interweve debug and logging messages.
             </summary>
             <param name="message">String message to send to browser.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.ErrorMessage(System.String,System.String)">
             <summary>
             Send an error message back to the browser console and highlight it read.
             </summary>
             <param name="message">Message we'd like shown in console.</param>
             <param name="stacktrace">Stacktrace to show in the console.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SecurityType(System.Collections.Generic.List{QuantConnect.SecurityType})">
             <summary>
             Send a list of secutity types that the algorithm trades to the browser to show the market clock - is this market open or closed!
             </summary>
             <param name="types">List of security types</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.RuntimeError(System.String,System.String)">
             <summary>
             Send a runtime error back to the users browser and highlight it red.
             </summary>
             <param name="message">Runtime error message</param>
             <param name="stacktrace">Associated error stack trace.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)">
             <summary>
             Add a sample to the chart specified by the chartName, and seriesName.
             </summary>
             <param name="chartName">String chart name to place the sample.</param>
             <param name="chartType">Type of chart we should create if it doesn't already exist.</param>
             <param name="seriesName">Series name for the chart.</param>
             <param name="seriesType">Series type for the chart.</param>
             <param name="time">Time for the sample</param>
             <param name="value">Value for the chart sample.</param>
             <param name="unit">Unit for the chart axis</param>
             <remarks>Sample can be used to create new charts or sample equity - daily performance.</remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SampleEquity(System.DateTime,System.Decimal)">
             <summary>
             Wrapper methond on sample to create the equity chart.
             </summary>
             <param name="time">Time of the sample.</param>
             <param name="value">Equity value at this moment in time.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SampleAssetPrices(QuantConnect.Symbol,System.DateTime,System.Decimal)">
             <summary>
             Sample the asset prices to generate plots.
             </summary>
             <param name="symbol">Symbol we're sampling.</param>
             <param name="time">Time of sample</param>
             <param name="value">Value of the asset price</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SamplePerformance(System.DateTime,System.Decimal)">
             <summary>
             Sample the current daily performance directly with a time-value pair.
             </summary>
             <param name="time">Current backtest date.</param>
             <param name="value">Current daily performance value.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SampleBenchmark(System.DateTime,System.Decimal)">
             <summary>
             Sample the current benchmark performance directly with a time-value pair.
             </summary>
             <param name="time">Current backtest date.</param>
             <param name="value">Current benchmark value.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.IResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SampleRange(System.Collections.Generic.List{QuantConnect.Chart})">
             <summary>
             Add a range of samples from the users algorithms to the end of our current list.
             </summary>
             <param name="updates">Chart updates since the last request.</param>
             <seealso cref="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Sample(System.String,System.String,System.Int32,QuantConnect.SeriesType,System.DateTime,System.Decimal,System.String)" />
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SetAlgorithm(QuantConnect.Interfaces.IAlgorithm)">
             <summary>
             Set the algorithm of the result handler after its been initialized.
             </summary>
             <param name="algorithm">Algorithm object matching IAlgorithm interface</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SendStatusUpdate(QuantConnect.AlgorithmStatus,System.String)">
             <summary>
             Send a algorithm status update to the user of the algorithms running state.
             </summary>
             <param name="status">Status enum of the algorithm.</param>
             <param name="message">Optional string message describing reason for status change.</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.RuntimeStatistic(System.String,System.String)">
             <summary>
             Set a dynamic runtime statistic to show in the (live) algorithm header
             </summary>
             <param name="key">Runtime headline statistic name</param>
             <param name="value">Runtime headline statistic value</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SendFinalResult(QuantConnect.Packets.AlgorithmNodePacket,System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.DateTime,System.Decimal},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},QuantConnect.Statistics.StatisticsResults,System.Collections.Generic.Dictionary{System.String,System.String})">
             <summary>
             Send a final analysis result back to the IDE.
             </summary>
             <param name="job">Lean AlgorithmJob task</param>
             <param name="orders">Collection of orders from the algorithm</param>
             <param name="profitLoss">Collection of time-profit values for the algorithm</param>
             <param name="holdings">Current holdings state for the algorithm</param>
             <param name="statisticsResults">Statistics information for the algorithm (empty if not finished)</param>
             <param name="runtime">Runtime statistics banner information</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreLog(System.Collections.Generic.IEnumerable{QuantConnect.Logging.LogEntry})">
             <summary>
             Process the log entries and save it to permanent storage 
             </summary>
             <param name="logs">Log list</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.StoreResult(QuantConnect.Packets.Packet,System.Boolean)">
             <summary>
             Save the snapshot of the total results to storage.
             </summary>
             <param name="packet">Packet to store.</param>
             <param name="async">Store the packet asyncronously to speed up the thread.</param>
             <remarks>
                 Async creates crashes in Mono 3.10 if the thread disappears before the upload is complete so it is disabled for now.
                 For live trading we're making assumption its a long running task and safe to async save large files.
             </remarks>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.OrderEvent(QuantConnect.Orders.OrderEvent)">
             <summary>
             New order event for the algorithm backtest: send event to browser.
             </summary>
             <param name="newEvent">New event details</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Exit">
             <summary>
             Terminate the result thread and apply any required exit proceedures.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.PurgeQueue">
             <summary>
             Purge/clear any outstanding messages in message queue.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.Truncate(QuantConnect.Packets.LiveResult,System.DateTime,System.DateTime)">
             <summary>
             Truncates the chart and order data in the result packet to within the specified time frame
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.SetChartSubscription(System.String)">
             <summary>
             Set the chart name that we want data from.
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Results.LiveTradingResultHandler.ProcessSynchronousEvents(System.Boolean)">
             <summary>
             Process the synchronous result events, sampling and message reading. 
             This method is triggered from the algorithm manager thread.
             </summary>
             <remarks>Prime candidate for putting into a base class. Is identical across all result handlers.</remarks>
            </member>
        <member name="T:QuantConnect.Lean.Engine.Engine">
             <summary>
             LEAN ALGORITHMIC TRADING ENGINE: ENTRY POINT.
             
             The engine loads new tasks, create the algorithms and threads, and sends them 
             to Algorithm Manager to be executed. It is the primary operating loop.
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Engine.SystemHandlers">
             <summary>
             Gets the configured system handlers for this engine instance
             </summary>
            </member>
        <member name="P:QuantConnect.Lean.Engine.Engine.AlgorithmHandlers">
             <summary>
             Gets the configured algorithm handlers for this engine instance
             </summary>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.#ctor(QuantConnect.Lean.Engine.LeanEngineSystemHandlers,QuantConnect.Lean.Engine.LeanEngineAlgorithmHandlers,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:QuantConnect.Lean.Engine.Engine" /> class using the specified handlers
             </summary>
             <param name="systemHandlers">The system handlers for controlling acquisition of jobs, messaging, and api calls</param>
             <param name="algorithmHandlers">The algorithm handlers for managing algorithm initialization, data, results, transaction, and real time events</param>
             <param name="liveMode">True when running in live mode, false otherwises</param>
            </member>
        <member name="M:QuantConnect.Lean.Engine.Engine.Run(QuantConnect.Packets.AlgorithmNodePacket,System.String)">
             <summary>
             Runs a single backtest/live job from the job queue
             </summary>
             <param name="job">The algorithm job to be processed</param>
             <param name="assemblyPath">The path to the algorithm's assembly</param>
            </member>
    </members>
</doc>
